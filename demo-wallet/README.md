# 虚拟钱包系统

基于贫血模型的MVC三层架构，是标准的Web项目开发模式，但是违反面向对象编程风格，是一种彻底的面向过程编程，被称为[反模式](https://zh.wikipedia.org/wiki/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F)。

领域驱动设计（Domain Driven Design，DDD）的盛行，使得基于贫血模型的传统开发模式被人诟病，基于充血模型的DDD开发模式被人提倡

## 背景知识

### 基于贫血模型的传统开发模式

传统MVC三层架构开发模式：

- M：Model，数据层
- V：View，展示层
- C：Controller，逻辑层

一般在前后端分离的项目中，后端负责暴露接口给前端调用，此时，后端项目被分为：

- Repository层：负责数据访问
- Service层：负责业务逻辑
- Controller层：负责暴露接口

> 依赖数据库开发的Web项目，基本上地分层思路都是这样的。

[贫血模型](./anaemic-domain-model.go)的示例，平时开发Web项目，基本都是按照这样的形式组织代码。

UserEntity 和 UserRepository 组成数据访问层，UserBo 和 UserService 组成业务逻辑层，UserVo 和 UserController 组成接口层。

从代码中发现，UserBo 是一个纯粹的数据结果，只有数据没有业务逻辑。业务逻辑集中在 UserService 中，通过 UserService 来操作 UserBo。也就是说 Service 层的数据和业务逻辑被分割为 BO 和 Service 两个类。

像 UserBo 这样只包含数据，没有业务逻辑的类称为**贫血模型**。因此，UserVo 和 UserEntity 也是贫血模型，这样的设计破坏类面向对象**封装**特性，是一种面向过程编程风格。

### 基于充血模型的DDD开发模式

在贫血模型中，数据和业务逻辑被分割在不同的类中，在充血模型中，数据和对应的业务逻辑被封装在同一个类中，因此满足面向对象的封装特性，是一种面向对象编程风格。

DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及交互。借着微服务的东风，领域驱动设计火了起来。

> 除了监控、调用链路追踪，API网关等服务治理能力外，微服务的主要工作是针对公司业务系统，合理地做微服务拆分，领域驱动设计就是用来指导服务划分的，所以，微服务加速来领域驱动设计的盛行。

做好领域驱动设计的关键是对业务系统的熟悉程度，而不是，对DDD概念的掌握程度，所以DDD有点像敏捷开发、SOA、PAAS等概念。因此。懂DDD的概念就行，熟悉业务才是王道。

基于充血模型的DDD开发也是按照MVC三层架构分层的：

- Repository层：负责数据存取
- Service层：负责核心业务逻辑【与贫血模型的开发模式的主要区别在这里】
- Controller层：负责暴露接口

|-|贫血模型|充血模型|
|---|---|---|
|Service层|包含 Service 类（业务逻辑）和 BO 类（数据）|包含 Service 类（这个很薄）和 Domain 类（相当于BO，但包含业务逻辑）|

- 基于贫血模型的传统开发模式：重 Service 而轻 BO
- 基于充血模型的DDD开发模式：轻 Service 而重 Domain

### 基于贫血模型的传统开发模式受欢迎的原因

有多流行呢，Spring 框架的官方 demo 也是基于贫血模型的传统开发模式编写的。

> 回忆下面向过程的弊端：数据和操作分离，数据本身的操作不受限制，任何代码可以随意修改数据。

流行的原因：

1. 业务系统比较简单，基于 SQL 的 CURD，不需要精心设计的充血模型。（业务简单，设计出来的领域模型会比较淡薄，和贫血模型差别不大，意义不大。）
2. 充血模型的设计比贫血模型难很多。（充血模型是一种面向对象编程风格，从一开始就要定义好数据暴露的操作，和业务逻辑，而不像贫血模型，一开始只要定义数据，业务逻辑是随着开发需求慢慢定义的，实现不需要太多设计。）
3. 思维固化，转型成本高。（转向充血模型和领域驱动设计，有一定地学习成本，在开发中没有遇到痛点的时候，很难推动。）

### 优先考虑基于充血模型的DDD开发模式的项目特征

- 基于贫血模型的传统开发模式：适合业务比较简单的系统
- 基于充血模型的DDD开发模式：适合业务比较复杂的系统，（如，包含各种利息计算模型、还款模型等复杂业务的金融系统。）

落地到代码层面的区别：一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中。更重要的区别是，两种不同的开发模式导致的开发流程不同，充血模式的开发流程在应对复杂业务系统的开发时更有优势。

> 最常见的地开发模式，基于 SQL 驱动（SQL-Driven）的开发模式：
>
> 1. 接口后端接口开发需求，查看接口需要的数据对应数据库中的表
> 2. 思考编写 SQL 获取数据
> 3. 定义 Entity、BO、VO
> 4. 模版式的往 Repository、Service、Controller 类中添加代码
>
> 业务逻辑包裹在一个大 SQL 中，Service 层做的事情很少，SQL针对特定业务功能，复用性差，新业务需要写新的 SQL，导致各种类似的 SQL 满天飞。

在这样地开发模式中，没有领域模型，么哦有oop，没有代码复用的意识。对于简单业务系统，问题不大，对于复杂业务系统，难易维护。

> 基于充血模型的DDD开发模式：
>
> 1. 梳理所有业务
> 2. 定义领域模型所包含的属性和方法，（领域模型相当于可服用的中间层，新功能需求基于定义好的领域模型来完成）

**越复杂的系统，对代码的复用性越高，易维护性要求高，应该花更多的时间和精力在前期的设计**。基于充血模型的DDD开发模式，就需要前期大量的业务调研，领域模型设计，所以适合复杂的业务系统开发。

但是DDD不是银弹，对于不复杂的系统，基于贫血模型的传统开发模式简单够用，基于充血模型的DDD开发模式就大材小用来，无法发挥作用。

## 实战---钱包业务

具有支付、购买功能的应用都支持钱包的功能，应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。

以下实战案例，实现一个支持充值、提现、支付、查询余额、查询交易流水这5个功能的虚拟钱包。

1. 充值：从用户银行卡账户转账到应用的公共银行卡账户；将用户充值的金额添加搭配虚拟钱包的余额；记录这一笔交易流水。
2. 支付：用户虚拟钱包账户划钱到商家虚拟钱包账户；记录这一笔交易流水。
3. 提现：扣减用户虚拟钱包中的余额；从应用的公共银行账户赚钱到用户的银行账户；记录这一笔交易流水。
4. 查询余额：显示用户虚拟钱包中的余额。
5. 查询交流流水：只支持充值、支付和提现流水的查询，将之前记录的交易流水，按照时间、类型等条件筛选过了后显示。

### 设计思路

基于上面的业务流转和数据流转。将钱包系统的业务划分为两部分：

- 单纯和应用内的虚拟钱包账户打交道
- 单纯和银行账户打交道

基于业务划分，解耦系统，将整个钱包系统拆分为两个子系统，虚拟钱包系统和三方支付系统。

|虚拟钱包|三方支付|
|---|---|
|用户虚拟钱包|用户银行卡|
|商家虚拟钱包|商家银行卡|
|/|应用公共银行卡|

要支持钱包的5个功能，虚拟钱包需要提供的操作：

|功能|虚拟钱包操作|描述|
|---|---|---|
|充值| + 余额|单账户|
|提现| - 余额|单账户|
|支付| + - 余额|两个账户|
|查询余额|查询余额|单账户|
|查询交易流水|记录/查询|交易流水ID、交易时间、交易金额、交易类型（充值、提现、支付）、入账钱包账号、出账钱包账号|

### 代码实现

1. [基于贫血模型的传统开发模式](./wallet-anaemic.go)
2. [基于充血模型的DDD开发模式](./wallet-rich.go)

在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄，但在代码设计与实现中，并没有完全将 Service 类去掉。

那么 Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？ 区别于 Domain 的职责，Service 类主要职责如下：

1. Service 类负责与 Repository 交流：调用 Repository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。
2. Service 类负责跨领域模型的业务聚合功能：如 transfer() 转账函数会涉及两个钱包的操作，这部分业务逻辑无法放到 VirtualWallet 类中，所以，把转账业务放到 VirtualWalletService 类中。随着功能演进，转账业务变得复杂后，可以将转账业务抽取出来，设计成一个独立的领域模型。
3. Service 类负责一些非功能性及与三方系统交互的工作：比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。

> 之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那为了**保持领域模型的独立性**，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加**可复用**。

在基于充血模型的 DDD 开发模式中，Service 层被改造成了充血模型，Controller 层和 Repository 层否有必要也进行充血领域建模呢？

通常来说没有必要，Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多。如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。

> Controller 和 Repository 层使用面向过程编程的副作用：
>
> - Repository 中的 Entity 类没有被封装起来，有被任意代码修改数据的风险。但是 Entity 的生命周期优先，传递到 Service 层后被转换为 BO 或 Domain，生命周期结束，不会被其他地方任意修改。
> - Controller 中的 VO，实际上是一种DTO（Data Transfer Object，数据传输对象），主要是作为接口的数据传输承载体，将数据发送到其他系统，功能上来说，只包含不包含业务逻辑，只包含数据，贫血模型更合理。
