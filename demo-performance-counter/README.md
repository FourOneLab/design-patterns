# 性能计数器

## 需求

获取接口调用的各种统计信息，比如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）输出到各种终端（Console 命令行、HTTP 网页、Email、日志文件、自定义输出终端等），以方便查看。

作为一个通用的框架，应用到各种业务系统中，支持实时计算，查看数据的统计信息等。

## 需求分析

性能计数器作为一个跟**业务无关**的功能，把它开发成一个独立的框架或者类库，集成到其他业务系统中。而作为可被**复用**的框架，除了功能性需求之外，非功能性需求也非常重要。

### 功能性需求

1. 接口统计信息：包括接口响应时间/接口调用次数的统计信息等。
2. 统计信息的类型：max、min、avg、percentile、count、tps 等。
3. 统计信息显示格式：JSON、HTML、自定义显示格式。
4. 统计信息显示终端：Console、Email、HTTP 网页、日志、自定义显示终端。

可以更细化到每一个需求的原型图。发现一些更细节的需求：

- 统计触发方式：包括主动和被动两种。
  - 主动：以一定的频率定时统计数据，并主动推送到显示终端，比如邮件推送。
  - 被动：用户触发统计，比如用户在网页中选择要统计的时间区间，触发统计，并将结果显示给用户。
- 统计时间区间：支持自定义统计时间区间，比如统计最近 10 分钟的某接口的 tps、访问次数，或者统计 `2021-12-11 00:00:00` ~~~ `2021-12-12 00:00:00` 之间某接口响应时间的最大值、最小值、平均值等。
- 统计时间间隔：对于主动触发统计，要支持指定统计时间间隔（即多久触发一次统计显示）。比如，每间隔 10s 统计一次接口信息并显示到命令行中，每间隔 24 小时发送一封统计信息邮件。

### 非功能性需求

1. 易用性：在开发技术框架时，也要有产品意识。框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等，都是应该花心思去思考和设计的。有的时候，文档写得好坏甚至都有可能决定一个框架是否受欢迎。
2. 性能：对于需要集成到业务系统的框架来说，不希望框架本身的代码执行效率，对业务系统有太多性能上的影响。
   1. 一方面，希望它是低延迟的，统计代码不影响或很少影响接口本身的响应时间；
   2. 另一方面，希望框架本身对内存的消耗不能太大。
3. 扩展性：与代码的扩展性类似，在不修改或尽量少修改代码的情况下添加新的功能。但是这两者也有区别：
   1. 代码的扩展性是从框架代码开发者的角度来说的。
   2. 框架/类库的扩展性是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能，类似给框架开发插件。
4. 容错性：这一点也**非常重要**。对于性能计数器框架来说，不能因为框架本身的异常导致接口请求出错。所以，要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。
5. 通用性：为了提高框架的复用性，能够灵活应用到各种场景中。框架在设计时，要尽可能通用，除了接口统计需求，还可以适用到其他哪些场景中，比如是否可以处理其他事件的统计信息，比如 SQL 请求时间的统计信息、业务统计信息（比如支付成功率）等。

## 框架设计

对于稍微复杂系统的开发，可以借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型（也称为MVP）。**尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见、摸得着，比较具体、不抽象，能够很有效地帮助我们缕清更复杂的设计思路，是迭代设计的基础**。

> 好比做算法题目，可以先写几组测试数据，找找规律，再想一个最简单的算法去解决它。虽然这个最简单的算法在时间、空间复杂度上可能都不令人满意，但是可以基于此来做优化，这样思路就会更加顺畅。

### Minimum Viable Product

对于性能计数器这个框架的开发来说，可以先聚焦于一个非常具体、简单的应用场景，比如统计用户注册、登录这两个接口的响应时间的最大值和平均值、接口调用次数，并且将统计结果以 JSON 的格式输出到命令行中。现在这个需求简单、具体、明确，设计实现起来难度降低了很多。

要输出接口的响应时间的最大值、平均值和接口调用次数，首先要采集每次接口请求的响应时间，并且存储起来，然后按照某个时间间隔做聚合统计，最后才是将结果输出。

在原型系统的代码实现中，可以把所有代码都塞到一个类中，暂时不用考虑任何代码质量、线程安全、性能、扩展性等等问题，怎么简单怎么来就行。最小原型的代码（MVP）实现如[示例](mvp.go)所示，以及使用场景的[示例](mvp_usage.go)。

最小原型的代码实现虽然简陋，但它却帮我们将思路理顺了很多，现在就基于它做最终的框架设计。

### 最终设计

下面是针对性能计数器框架画的一个粗略的系统设计图。可以非常直观地体现设计思想，并且能有效地帮助我们释放更多的脑空间，来思考其他细节问题。

```shell
数据采集（响应/访问时间）---> 存储（内存/DB/日志/文件）---> 聚合统计（max、min、avg、count、tps）---> 显示（Console、Email、HTTP、自定义）
```

把整个框架分为4个模块：数据采集、存储、聚合统计、显示，每个模块负责的工作如下。

- **数据采集**：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。**数据采集过程要高度容错，不能影响到接口本身的可用性**。除此之外，因为这部分功能是暴露给框架的使用者的，所以在设计数据采集 API 的时候，要尽量考虑其**易用性**。
- **存储**：负责将采集的原始数据保存下来，以便后面做聚合统计。数据的存储方式有多种，比如：Redis、MySQL、HBase、日志、文件、内存等。数据存储比较耗时，为了尽量地减少对接口性能（比如响应时间）的影响，采集和存储的过程**异步**完成。
- **聚合统计**：负责将原始数据聚合为统计数据，比如：max、min、avg、percentile、count、tps 等。为了支持更多的聚合统计规则，代码希望尽可能**灵活**、**可扩展**。
- **显示**：负责将统计数据以某种格式显示到终端，比如：输出到命令行、邮件、网页、自定义显示终端等。

其他的一些设计细节：

- 统计触发方式：主动推送、被动触发统计
- 统计时间区间：统计哪一个时间段内的数据
- 统计时间间隔：对于主动推送方法，多久统计推送一次

对于互联网项目来说，**小步快跑**、**逐步迭代**是一种更好的开发模式。所以，分多个版本逐步完善这个框架。

第一个版本先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0……版本中继续迭代优化。

## 第一版

针对框架 v1.0 版本的开发中，暂时只实现下面这些功能。

- 数据采集：负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间。
- 存储：负责将采集的原始数据保存下来，以便之后做聚合统计。数据的存储方式有很多种，暂时只支持 Redis 这一种存储方式，并且，采集与存储两个过程同步执行。
- 聚合统计：负责将原始数据聚合为统计数据，包括响应时间的最大值、最小值、平均值、99.9 百分位值、99 百分位值，以及接口请求的次数和 tps。
- 显示：负责将统计数据以某种格式显示到终端，暂时只支持主动推送给命令行和邮件。命令行间隔 n 秒统计显示上 m 秒的数据（比如，间隔 60s 统计上 60s 的数据）。邮件每日统计上日的数据。

> 现在这个版本的需求比之前的要更加具体、简单了，实现起来也更加容易一些。实际上，学会结合具体的需求，做合理的预判、假设、取舍，规划版本的迭代设计开发，也是一个资深工程师必须要具备的能力。

在实际的软件开发中，面向对象设计与实现这两个过程往往是交叉进行的。一般是先有一个粗糙的设计，然后着手实现，实现的过程发现问题，再回过头来补充修改设计。

在上面 MVP 的示例中，所有代码都耦合在一个类中，这显然是不合理的。按照面向对象设计的几个步骤，来重新划分、设计类。

### 划分职责进而识别出有哪些类

根据需求描述，先大致识别出下面几个接口或类。这一步不难，完全就是翻译需求。

- MetricsCollector 类负责提供 API，来采集接口请求的原始数据。可以为 MetricsCollector 抽象出一个接口，但这并不是必须的，因为暂时只能想到一个 MetricsCollector 的实现方式。
- MetricsStorage 接口负责原始数据存储，RedisMetricsStorage 类实现 MetricsStorage 接口。这样做是为今后灵活地扩展新的存储方法，比如用 HBase 来存储。
- Aggregator 类负责根据原始数据计算统计数据。
- ConsoleReporter 类、EmailReporter 类分别负责以一定频率统计并发送统计数据到命令行和邮件。至于 ConsoleReporter 和 EmailReporter 是否可以抽象出可复用的抽象类，或者抽象出一个公共的接口，暂时还不能确定。

### 定义类及类与类之间的关系

定义类及属性和方法，定义类与类之间的关系。

大致地识别出几个核心的类之后，习惯性的做法是，先在 IDE 中创建好这几个类，然后开始试着定义它们的属性和方法。

> 在设计类、类与类之间交互的时候，不断地用设计原则和思想来审视设计是否合理，比如，是否满足单一职责原则、开闭原则、依赖注入、KISS 原则、DRY 原则、迪米特法则，是否符合基于接口而非实现编程思想，代码是否高内聚、低耦合，是否可以抽象出可复用代码等等。

如[示例](metrics_collector_v1.go)所示，MetricsCollector 类和 MetricsStorage 类的设计思路比较简单。但是，统计和显示这两个功能就有多种设计思路。

把统计显示所要完成的功能逻辑细分一下，主要包含下面 4 点：

1. 根据给定的时间区间，从数据库中拉取数据；
2. 根据原始数据，计算得到统计数据；
3. 将统计数据显示到终端（命令行或邮件）；
4. 定时触发以上 3 个过程的执行。

面向对象设计和实现要做的事情，就是**把合适的代码放到合适的类中**。

> 所以，现在的工作就是，把以上的 4 个功能逻辑划分到几个类中。划分的方法有很多种：
>
> - 把前两个逻辑放到一个类中，第 3 个逻辑放到另外一个类中，第 4 个逻辑作为上帝类（God Class）组合前面两个类来触发前 3 个逻辑的执行。
> - 把第 2 个逻辑单独放到一个类中，第 1、3、4 都放到另外一个类中。

选择哪种排列组合方式，判定的标准是，让代码尽量地满足低耦合、高内聚、单一职责、对扩展开放对修改关闭等各种设计原则和思想，尽量地让设计满足代码易复用、易读、易扩展、易维护。

[示例](metrics_collector_v1.go)代码中的实现方式选择第2种。把第 1、3、4 逻辑放到 ConsoleReporter 或 EmailReporter 类中，把第 2 个逻辑放到 Aggregator 类中。

### 将类组装起来并提供执行入口

因为这个框架稍微有些特殊，有两个执行入口：

- 一个是 MetricsCollector 类，提供了一组 API 来采集原始数据；
- 另一个是 ConsoleReporter 类和 EmailReporter 类，用来触发统计显示。
