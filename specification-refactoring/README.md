# 规范与重构

把持续重构作为开发的一部分。

重构难在哪里呢？

- 一方面，重构代码比单纯写代码要求高得多。重构需要能洞察出代码存在的坏味道或者设计上的不足，并且能合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题。
- 另一方面，对为什么要重构、到底重构什么、什么时候重构、又该如何重构等相关问题理解不深，对重构没有系统性、全局性的认识，面对一堆烂代码，没有重构技巧的指导，只能想到哪改到哪，并不能全面地改善代码质量。

## 重构的目的

> 重构定义：重构是一种对软件内部结构的改善，目的是在**不改变软件的可见行为**的情况下，使其更易理解，修改成本更低。

也就是说，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。

为什么要重构呢？

1. 重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。
2. 优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。无法 100% 遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的。
3. 重构是避免过度设计的有效手段。在维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。

重构也是快速成长的方式：

- 重构是对经典设计思想、设计原则、设计模式、编程规范的一种应用。
- 重构是将这些理论知识，应用到实践的一个很好的场景，能够锻炼我们熟练使用这些理论知识的能力。
- 平时堆砌业务逻辑，总觉得没啥成长，而将一个比较烂的代码重构成一个比较好的代码，会很有成就感。
- 重构能力也是衡量一个工程师代码能力的有效手段。所谓“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”：
  - 初级工程师在已有代码框架下修改 bug、修改添加功能代码；
  - 高级工程师从零开始设计代码结构、搭建代码框架；
  - 资深工程师为代码质量负责，需要发觉代码存在的问题，重构代码，时刻保证代码质量处于一个可控的状态。

## 重构的对象

根据重构的规模，笼统地分为大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）。

大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是**设计思想**、**原则**和**模式**。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。

小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多的是利用**编码规范**。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小。只需要熟练掌握各种编码规范，就可以做到得心应手。

## 重构的时机

> 当代码烂到出现“开发效率低，招了很多人，天天加班，出活却不多，线上 bug 频发，领导发飙，中层束手无策，工程师抱怨不断，查找 bug 困难”的时候，基本上重构也无法解决问题了。

**必须探索一条可持续、可演进的方式**，提倡的重构策略是**持续重构**。把单元测试、Code Review 作为开发的一部分，能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。

技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。

## 重构的方法

对于大型重构来说，因为涉及的模块、代码会比较多，如果项目代码质量又比较差，耦合比较严重，往往会牵一发而动全身。因此，要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。

- 大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。
- 小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要愿意且有时间，随时都可以去做。

除了人工去发现低层次的质量问题，还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。

**保持代码质量最好的方法还是打造一种好的技术氛围，以此来驱动大家主动去关注代码质量，持续重构代码**。

## 重构的手段

如何保证重构不出错呢?

1. 需要熟练掌握各种设计原则、思想、模式，
2. 需要对所重构的业务和代码有足够的了解。
3. 除了这些个人能力因素之外，最可落地执行、最有效的保证重构不出错的手段应该就是**单元测试**（Unit Testing）了。

重构完成后，如果新的代码仍然能通过单元测试，那就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变。

### 单元测试

单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。

- 单元测试相对于集成测试（Integration Testing），测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端（end to end）的测试。
- 单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行，是代码层级的测试。

看个[示例](unit_testing_v1.go)，对 Text 类的 `ToNumber()` 方法进行单元测试，判断其实现逻辑的正确性。

> 写单元测试本身不需要什么高深技术，更多的是考验思维的缜密程度，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。

为了保证测试的全面性，针对 `ToNumber()` 方法，设计下面这样几个测试用例：

1. 如果字符串只包含数字：“123”，`ToNumber()` 函数输出对应的整数：123
2. 如果字符串是空或者 null，`ToNumber()` 函数返回：null
3. 如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，`ToNumber()` 返回对应的整数：123
4. 如果字符串包含多个首尾空格：“ 123 ”，`ToNumber()` 返回对应的整数：123
5. 如果字符串包含非数字字符：“123a4”，“123 4”，`ToNumber()` 返回 null

看[单元测试](unit_testing_v1_test.go)，以表格驱动测试。

#### 为何要写单元测试

单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。

1. 单元测试能有效地帮你发现代码中的 bug
2. 写单元测试能帮你发现代码设计上的问题：代码的可测试性是评判代码质量的一个重要标准，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等，会导致代码难以测试
3. 单元测试是对集成测试的有力补充:
   1. 程序运行的 bug 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。可以通过控制 mock 的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。
   2. 对于一些复杂系统，集成测试也无法覆盖得很全面。复杂系统往往有很多模块。每个模块都有各种输入、输出、异常情况，组合起来，整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，再强大的测试团队也无法穷举完备。通过单元测试能保证每个类、每个函数都能按照预期来执行，底层 bug 少了，那组装起来的整个系统，出问题的概率也就相应减少了。
4. 写单元测试的过程本身就是代码重构的过程
5. 阅读单元测试能帮助你快速熟悉代码：单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。
6. 单元测试是 TDD（Test-Driven Development） 可落地执行的改进方案

#### 测试框架

Golang自带了测试框架，可以看这边[官方博客](https://blog.golang.org/subtests)。

#### 覆盖率

单元测试覆盖率是比较容易量化的指标，常常作为单元测试写得好坏的评判标准。

Golang自带了覆盖率统计工具，可以看这边[官方博客](https://blog.golang.org/cover)。

覆盖率的计算方式有很多种，比较简单的是语句覆盖，稍微高级点的有：条件覆盖、判定覆盖、路径覆盖。

不管覆盖率的计算方式如何高级，将覆盖率作为衡量单元测试质量的唯一标准是不合理的。实际上，更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些 corner case。

单元测试不要依赖被测试函数的具体实现逻辑，它**只关心被测函数实现了什么功能**。切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也违背了写单元测试的初衷。

### 代码的可测试性

如[示例](transaction.go)所示,Transaction 是经过我抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。

- Transaction 类中的 `Execute()` 方法负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。
- 真正的转账操作是通过调用 WalletRpcService RPC 服务来完成的。
- 代码中还涉及一个分布式锁 DistributedLock 单例类，用来避免 Transaction 并发执行，导致用户的钱被重复转出。

#### Execute 方法

设计如下的6个测试用例：

1. 正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的 walletTransactionId，交易状态设置为 EXECUTED，函数返回 true。
2. buyerId、sellerId 为 null、amount 小于 0，返回 InvalidTransactionException。
3. 交易已过期（createTimestamp 超过 14 天），交易状态设置为 EXPIRED，返回 false。
4. 交易已经执行了（status==EXECUTED），不再重复执行转钱逻辑，返回 true。
5. 钱包（WalletRpcService）转钱失败，交易状态设置为 FAILED，函数返回 false。
6. 交易正在执行着，不会被重复执行，函数直接返回 false。

`Execute()` 函数的执行依赖外部RPC服务，这就导致单元测试代码存在下面的问题：

1. 需要搭建 Wallet RPC 服务，搭建和维护的成本比较高。
2. 需要保证将伪造的 transaction 数据发送给 Wallet RPC 服务之后，能够正确返回期望的结果，然而 Wallet RPC 服务是第三方服务，并不是可控的。
3. Transaction 的执行跟 RPC 服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响。
4. 网络的中断、超时、RPC 服务的不可用，都会影响单元测试的执行。

回到单元测试的定义上来看一下。单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统的逻辑正确性。

所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那就需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作“mock”。

所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。mock 的方式主要有两种，手动 mock 和利用框架 mock。利用框架 mock 仅仅是为了简化代码编写，每个框架的 mock 方式都不大一样。

在示例中，编写了两个MockWalletRPCService来实现对返回数据的控制，而不需要真正通过网络。

因为 WalletRpcService 是在 `Execute()` 方法中通过 new 的方式创建的，无法动态地对其进行替换。也就是说，Transaction 类中的 `Execute()` 方法的可测试性很差，需要通过重构来让其变得更容易测试。

依赖注入是实现代码可测试性的最有效的手段，应用依赖注入，将 WalletRpcService 对象的创建反转给上层逻辑，在外部创建好之后，再注入到 Transaction 类中。具体实现就是在 Transaction 中增加一个 WalletRPC 接口字段，在 NewTransaction 的时候将RPC注入。

在涉及到与时间相关到判断时，通常会封装一个 `isExpired()` 方法，来判断是否过期等情况。

#### NewTransaction 函数

在看构造函数并非只包含简单赋值操作。交易 id 的赋值逻辑稍微复杂。也需要写单元测试，以保证这部分逻辑的正确性。为了方便测试，把 id 赋值这部分逻辑单独抽象到一个函数 `fillTransactionId()` 中，

实际上，可测试性差的代码，本身代码设计得也不够好，很多地方都没有遵守设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。

重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。这也印证了代码的可测试性可以从侧面上反应代码设计是否合理。

除此之外，在平时的开发中，要多思考一下，这样编写代码，是否容易编写单元测试，这也有利于设计出好的代码。

### 常见的反模式

1. 未决行为：代码的输出是随机/不确定的，比如，跟时间、随机数有关的代码
2. 全局变量：是一种面向过程的编程风格，有种种弊端，滥用全局变量也让编写单元测试变得困难
3. 静态方法：是一种面向过程的编程思维，在代码中调用静态方法，有时候会导致代码不易测试，主要原因是静态方法很难 mock，但具体也要看情况
4. 复杂继承：相比组合关系，继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护，实际上，继承关系也更加难测试，因此 Golang 中只有组合没有继承，类之间的结构层次比较扁平，在编写单元测试的时候，只需要 mock 类所组合依赖的对象即可
5. 高度耦合代码：如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那在编写单元测试的时候，可能需要 mock 这十几个依赖的对象，不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。

## 解耦代码

重构可以分为大规模高层重构（简称“大型重构”）和小规模低层次重构（简称“小型重构”）。大型重构是对系统、模块、代码结构、类之间关系等顶层代码设计进行的重构。

对于大型重构来说，最有效的一个手段就是解耦。**解耦的目的是实现代码高内聚、松耦合**。

> 软件设计与开发最重要的工作之一就是**应对复杂性**。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。控制代码的复杂性，最关键的就是解耦，保证代码松耦合、高内聚。
>
> 如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。

怎么判断代码的耦合程度，或者说，怎么判断代码是否符合“高内聚、松耦合”，再或者说，如何判断系统是否需要解耦重构呢？

- 间接的衡量标准，看修改代码会不会牵一发而动全身。
- 直接的衡量标准，把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。

### 如何进行解耦

1. 封装与抽象：作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。
2. 中间件：引入中间层能简化模块或类之间的依赖关系。在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。为了让重构能小步快跑，引入中间件后，可以分为四个阶段来完成接口的重构。
   1. 第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。
   2. 第二阶段：新开发的代码依赖中间层提供的新接口。
   3. 第三阶段：将依赖老接口的代码改为调用新接口。
   4. 第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。
3. 模块化（分而治之）：构建复杂系统常用的手段。将系统划分成各个独立的模块，让不同的人负责不同的模块。不同的模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发，最终像搭积木一样将各个模块组装起来，构建成一个超级复杂的系统。再聚焦到代码层面，合理地划分模块能有效地解耦代码，提高代码的可读性和可维护性。所以，一定要有模块化意识，将每个模块都当作一个独立的 lib 一样来开发，只提供封装了内部实现细节的接口给其他模块使用，这样可以减少不同模块之间的耦合度。
4. 其他设计思想和原则：很多设计原则都以实现代码的“高内聚、松耦合”为目的：
   1. 单一职责原则：高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。
   2. 基于接口而非实现编程：通过接口这样一个中间层，隔离变化和具体的实现。在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。
   3. 依赖注入：将代码之间的强耦合变为弱耦合。尽管无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。
   4. 多用组合少用继承：继承是一种强依赖，组合是一种弱依赖，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。
   5. 迪米特法则：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。这条原则的目的就是为了实现代码的松耦合。
