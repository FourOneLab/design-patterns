# ID 生成器

重构就是发现代码质量问题，并且对其进行优化的过程。

## 需求背景

聚焦到软件开发中，ID 常用来表示一些**业务信息的唯一标识**（实际上是没有业务含义的，对用户来说是透明的，不需要关注），比如：

- 订单的单号或者数据库中的唯一主键
- 地址表中的 ID 字段

通常，为了方便在后端系统的请求出错时排查问题，在编写代码时会在关键路径上打印日志。

- 某个请求出错之后，希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。
- 而实际情况是，在日志文件中，不同请求的日志会交织在一起。
- 如果没有东西来标识哪些日志属于同一个请求，就无法关联同一个请求的所有日志。

> 这个需求有点像微服务中的**调用链追踪**。不过，微服务中的调用链追踪是**服务间**的追踪，现在要实现的是**服务内**的追踪。

借鉴微服务调用链追踪的实现思路，给每个请求分配一个唯一 ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。

- 在 Java 语言中，可以将 ID 存储在 Servlet 线程的 ThreadLocal 中，或者利用 Slf4j 日志框架的 MDC（Mapped Diagnostic Contexts）来实现（实际上底层原理也是基于线程的 ThreadLocal）。
- 在 Golang 语言中，每个请求的第一个入参是请求的上下文（Context），将 ID 存储在这个 Context 中。

每次打印日志时，从请求上下文中取出请求 ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求 ID 信息，就可以通过请求 ID 来搜索同一个请求的所有日志了。

## 示例

如[示例](id_generator_v1.go)所示。

### 如何发现代码质量问题

1. 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？
2. 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？
3. 设计模式是否应用得当？是否有过度设计？
4. 代码是否容易扩展？如果要添加新功能，是否容易实现？
5. 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
6. 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？
7. 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

除此之外，还要关注代码实现是否满足业务本身特有的功能和非功能需求。

1. 代码是否实现了预期的业务需求？
2. 逻辑是否正确？是否处理了各种异常情况？
3. 日志打印是否得当？是否方便 debug 排查问题？
4. 接口是否易用？是否支持幂等、事务等？
5. 代码是否存在并发问题？是否线程安全？
6. 性能是否有优化空间，比如，SQL、算法是否可以优化？
7. 是否有安全漏洞？比如输入输出校验是否全面？

### 重构代码

#### 提高代码可读性

对 IdGenerator 类重命名，并抽象出对应的接口。在命名的时候，要考虑到，以后两个类会如何使用、会如何扩展。

||接口|实现类|
|---|---|---|
|1|IdGenerator|LogTraceIdGenerator|
|2|LogTraceIdGenerator|HostNameMillisIdGenerator|
|3|LogTraceIdGenerator|RandomIdGenerator|

- 方式1：从使用和扩展的角度看不合理，
  - 如果要扩展新的日志 ID 生成算法，需要新建一个新的类，因为 LogTraceIdGenerator 这名字过于通用。
  - 如果要扩展其他业务的 ID 生成算法（如，UserIdGenerator、OrderIdGenerator），因为基于接口而非实现编程的目的是方便灵活的替换实现类，但是这几个类的场景完全不同，并不存在替换的情况，这样实现的接口没有意义。
- 方式2：接口的命名相当合理，但是实现类的命名中暴露类太多的细节，代码中稍有变动，就需要修改实现类的名字。
- 方式3：实现类的命名也比较合理，与实现的功能（随机生成一个 ID）对应，当扩展性新的日志 ID 生成算法时，增加新的实现类（如，SequenceIdGenerator）。

> 在 Golang 中，比较推荐小接口的方式，因此可以抽象出两个接口，IdGenerator 和 LogTraceIdGenerator，这样实现类可以复用的模块更多，甚至是不同的业务线，如[示例](id_generator_v2.go)所示。

#### 提高代码可测试性

写单元测试时，测试对象是函数定义的**功能**，而非具体的实现逻辑。这样才能做到，函数的实现逻辑改变了之后，单元测试用例仍然可以工作。

`Generate()` 函数实现的功能完全是由代码编写者来定义的。比如，针对同一份 `Generate()` 函数的代码实现，可以有 3 种不同的功能定义，对应 3 种不同的单元测试。

1. 如果把 `Generate()` 函数的功能定义为：“生成一个随机唯一 ID”，那只要测试多次调用 `Generate()` 函数生成的 ID 是否唯一即可。
2. 如果把 `Generate()` 函数的功能定义为：“生成一个只包含数字、大小写字母和中划线的唯一 ID”，那不仅要测试 ID 的唯一性，还要测试生成的 ID 是否只包含数字、大小写字母和中划线。
3. 如果把 `Generate()` 函数的功能定义为：“生成唯一 ID，格式为：{主机名 substring}-{时间戳}-{8 位随机数}。在主机名获取失败时，返回：null-{时间戳}-{8 位随机数}”，那不仅要测试 ID 的唯一性，还要测试生成的 ID 是否完全符合格式要求。

**单元测试用例如何写，关键看如何定义函数**。

> 针对 `Generate()` 函数的前两种定义，我们不需要 mock 获取主机名函数、随机函数、时间函数等，但对于第 3 种定义，需要 mock 获取主机名函数，让其返回 null，测试代码运行是否符合预期。

写单元测试的目的是为了减少代码 bug，而不是为了写单元测试而写单元测试。对于函数的实现非常简单，肉眼基本上可以排除明显的 bug，那么可以不为其编写单元测试代码。

### 错误处理

#### 返回错误码

如 C 语言中没有异常这样的语法机制，因此，返回错误码便是最常用的出错处理方式。比较新的编程语言中，大部分情况下，都用异常来处理函数出错的情况，极少会用到错误码。

在 C 语言中，错误码的返回方式有两种：

1. 一种是直接占用函数的返回值，函数正常执行的返回值放到出参中；
2. 另一种是将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码。

#### 返回 null / nil 值

在多数编程语言中，用 NULL 来表示“不存在”这种语义。

一般不建议函数返回 NULL 值，认为这是一种不好的设计思路，主要的理由有以下两个。

1. 如果某个函数有可能返回 NULL 值，在使用它的时候，忘记了做 NULL 值判断，就有可能会抛出空指针异常（Null Pointer Exception，缩写为 NPE）。
2. 如果定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。

```golang
package main

type User struct{}

type UserRepo struct{}

type UserService struct {
 userRepo UserRepo
}

func NewUserService() *UserService {
  return &UserService{}
}

// GetUser return user by telephone
func (u *UserService) GetUser(telephone string) *User {
 // If user not exist, return nil
 return nil
}

func main(){
 svc := NewUserService()
 if u := svc.GetUser("1234567890"); u != nil {
  // 
    }
}
```

对于数据不存在的情况，返回nil还是返回空对象，应该在整个项目维度定义一个统一的标准。

#### 返回空对象

返回 null / nil 值，不太好，硬刺可以返回空对象，如空字符串和空结构体，来代表数据不存在。

将上面例子中的 `GetUser`  的返回值修改下。

```golang
// GetUser return user by telephone
func (u *UserService) GetUser(telephone string) *User {
 // If user not exist, return empty User struct
 return &User{}
}
```

#### 抛出异常对象

尽管前面讲了很多函数出错的返回数据类型，但是，最常用的函数出错处理方式就是抛出异常（）。异常可以携带更多的错误信息，比如函数调用栈信息。除此之外，异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好。

在 Golang 这类多返回值的编程语言中，通常返回值的最后一个是 error，因此在函数调用的时候，优先判断返回值中是否存在异常，如果存在则直接处理异常，认为返回值无效。

#### 函数调用异常后的处理

1. 直接吞掉就地打印，记录到日志中：如果 `func1()` 抛出的异常是可以恢复，且 `func2()` 的调用方并不关心此异常
2. 继续向上抛出：如果 `func1()` 抛出的异常对 `func2()` 的调用方来说，是可以理解的、关心的 ，并且在业务概念上有一定的相关性
3. 包装后再继续向上抛：如果 `func1()` 抛出的异常太底层，对 `func2()` 的调用方来说，缺乏背景去理解、且业务概念上无关，可以将它重新包装成调用方可以理解的新异常

总之，是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出。