# 积分兑换系统

## 需求分析

积分是一种常见的营销手段，很多产品都会通过它来促进消费，增加用户粘性，比如淘宝积分、信用卡积分、商场消费积分等。

目前，需要为电商平台设计一个积分系统。

> 常见的做法：产品经理给出产品设计文档（PRD）、线框图，然后按照实现就行。

**技术人员应该参数到产品的设计中**。应该具备产品思维，而不是完全的技术控。

技术人做产品设计的2个注意点：

1. 不要闭门造车，一个人很难想得全面，而且从零开始设计也比较浪费时间。
2. 要学会借鉴，爱因斯坦说过：“创造的一大秘诀是要懂得如何隐藏你的来源”。参考类似产品，并使用相关的产品，并充分了解自己的产品，两者融合，进行微创新。

积分系统常见的2大功能：

1. 赚取积分：主要包括积分赚取渠道（下单、签到、评论等）和积分兑换规则（根据订单金额等比例兑换为积分）
2. 消费积分：主要包括积分消费渠道（抵扣、兑换优惠券、积分换购等）和积分兑换规则（积分抵扣或兑换优惠券的比例）

更多的业务细节通过产品的线框图、用户用例或者用户故事来细化业务流程，挖掘出一些比较细节的，不容易想到的功能点。

> 用户用例：类似于单元测试的用例，侧重情景化，模拟用户如何使用产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程，包含更多的细节，更加容易被人理解。

例如，积分有效期的用户用例：

1. 用户获取积分时，告知积分的有效期
2. 用户在使用积分时，优先使用快过期的积分
3. 用户在查询积分明细时，显示积分的有效期和状态
4. 用户在查询总积分时，排除已过期的积分

### 积分系统的具体需求

#### 积分赚取和兑换规则

积分赚取渠道：下单、签单、评论

积分兑换规则：签到送积分、按照订单金额的10%兑换为积分

积分的有效期：不同渠道的积分有效期不同，消费时优先使用快过期积分

#### 积分消费和兑换规则

积分消费渠道：抵扣、兑换优惠券、积分购物

积分兑换规则：不同消费渠道，积分兑换比例不同

#### 积分及明细查询

查询用户的总积分，以及赚取积分和消费积分的历史记录。

## 系统设计

面向对象设计聚焦在代码层面（主要是针对类），系统设计就聚焦在架构层面（主要是针对模块），两者有很多相似的地方。

> 很多设计原则和思想不仅可以应用到代码设计中，还可以用用到架构设计中。

### 合理地将功能划分到不同模块

> 面向对象设计的本质是把合适的代码放在合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。

类比面向对象设计，系统设计是将合适的功能放到合适的模块中，合理地划分模块，可以做到模块层面的高内聚、低耦合，架构整洁清晰。

对于积分兑换系统，有3中模块划分方法。

#### 方式1

积分赚取渠道及兑换规则、积分消费渠道及兑换规则的管理和维护（增删改查）不划分到积分系统中，而是放在更上层的营销系统中。

这样积分系统非常简单，只负责积增加积分、减少积分、查询积分等工作。

> 例如：用户通过下单获取积分。订单系统通过异步消息或者同步接口调用的方式，告知营销系统，订单交易成功。营销系统根据拿到的订单信息，查询订单对应的积分兑换规则（兑换比例和有效期等），计算得到订单可兑换的积分数量，然后调用积分系统的接口，给用户增加积分。

#### 方式2

积分赚取渠道及兑换规则、积分消费渠道及兑换规则的管理和维护（增删改查），分散在各个相关业务系统中，比如订单系统、评论系统、签单系统、换购商城、优惠券系统等。

> 还是用户通过下单获取积分的例子。用户下单成功后，订单系统更具商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。

#### 方式3

所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、积分消费渠道及兑换规则的管理和维护（增删改查）等。

> 还是用户通过下单获取积分的例子。用户下单成功后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分。

通过判断3种方式是否符合高内聚低耦合特性来判读合理性。**如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那么说明模块划分的不够合理，职责不够清晰，耦合过于严重**。

为了避免业务知识的耦合，让下层系统更加通用，一般不希望下层系统（被调用的系统）包含太多上层系统（调用系统）的业务信息，但是可以接受上层系统包含下层系统的业务信息。

> 如订单系统，优惠券系统、换购商城作为调用积分系统的上层系统，可以包含一些积分相关的业务信息，但是积分系统中，最好不要包含太多跟订单、优惠券、换购相关的信息。

因此，第1种和第2种，模块的划分更合理，这两种模式中，积分系统的职责是一样的，负责积分的增删改查。

### 设计模块与模块之间的交互关系

> 面向对象设计中，类设计完成后，需要设计类之间的交互关系。

类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，确定有哪些系统跟积分系统之间有交互以及如何交互。

常见的系统之间的交互有2种：

1. 同步接口调用：简单直接
2. 利用消息中间件异步调用：解耦效果好

> 例如：用户下订单成功之后，订单系统推送一条消息到消息中间件，营销系统订阅订单成功的消息，触发执行相应的积分兑换逻辑。**订单系统与营销系统完全解耦合**，订单系统不需要知道任何与积分相关的逻辑，而营销系统也不需要直接跟订单系统交互。

通常，**上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用**

> 如，营销系统和积分系统是上下层关系，比较推荐使用同步接口调用。

### 设计模块的接口、数据库和业务模型

模块划分完成，模块之间的交互确定后，模块本身的设计主要包括3方面的工作：

1. 接口设计
2. 数据库设计
3. 业务模型设计

数据库和接口的设计非常重要，一旦设计好并投入使用，不能轻易改动。即便微小的改动，执行起来也会非常麻烦。因此，设计接口和数据库的时候，一定要花心思，不要随意改动。

- 改动数据库表结构，需要涉及数据的迁移和适配
- 改动接口，需要推动接口的使用者进行相应的代码修改
- 业务模型侧重内部实现，不涉及被外部依赖的接口，也不包括持久化的数据，对改动的容忍性更大

#### 数据库的设计

只需要一种记录积分流水明细的表就可以了。表中记录积分的赚取和消费流水，用户积分的各种统计数据，如总积分，总可用积分等，可以通过这张表计算出来。

|字段|描述|
|---|----|
|id|明细ID|
|user_id|用户ID|
|channel_id|赚取或消费渠道ID|
|event_id|相关事件ID，如订单ID、评论ID、优惠券换购ID等|
|credit|积分（赚取为正，消费为负）|
|create_time|积分赚取或消费时间|
|expired_time|积分过期时间|

#### 接口设计

接口设计要符合单一职责原则、粒度越小通用性越好。为了兼顾易用性和性能，可以借鉴外观设计模式，在职责单一的细粒度接口之上，在封装一层粗粒度的接口给外部使用。

> 接口粒度太小会带来一些问题，如实现一个功能需要调用多个小接口，接口调用通过网络，多次远程接口调用会影响性能，本该在一个接口中完成的原子操作，被拆分为多个接口，会涉及分布式事物的数据一致性问题。

|接口|参数|返回值|
|---|---|---|
|赚取积分|userId、channelId、eventId、credit、expiredTime|积分明细ID|
|消费积分|userId、channelId、eventId、credit、expiredTime|积分明细ID|
|查询积分|userId|总可用积分|
|查询总积分明细|userId+分页参数|id、userId、channelId、eventId、credit、createTime、expiredTime|
|查询赚取积分明细|userId+分页参数|id、userId、channelId、eventId、credit、createTime、expiredTime|
|查询消费积分明细|userId+分页参数|id、userId、channelId、eventId、credit、createTime、expiredTime|

#### 业务模型设计

从代码实现的角度，大部分业务系统的开发都可以分为3层：

- Controller：负责接口暴露
- Service：负责核心业务逻辑
- Repository：负责数据读写

> 积分系统业务比较简单，因此基于贫血模型的传统开发模式进行，如果是比较复杂的系统，可以基于充血模型的DDD开发模式。

- 从开发的角度，积分系统可以作为独立的项目，也可以与其他的业务代码（如营销系统）放在同一个项目中。
- 从运维的角度，积分系统可以作为一个微服务独立部署，也可以将它跟其他业务一块部署。

> 讲道理，积分系统业务简单，代码量少，更适合与其他系统放在一个项目中开发部署，只要做好代码的模块化和解耦，让积分相关的业务代码和其他业务代码之间边界清晰，没有太多耦合，后期如果需要将它拆分为独立的项目开发部署也不难。

## 分 MVC 三层开发

对于简单的项目，为何也需要按照 MVC 进行三层开发呢？原因有如下几点。

### 分层能起到代码复用的作用

同一个 Repository 被多个 Service 调用，同一个 Service 被多个 Controller 调用。

> 比如，UserService 中的 `getUserById()` 接口封装了通过 ID 获取用户信息的逻辑，这部分逻辑可能会被 UserController 和 AdminController 等多个 Controller 使用。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。

### 分层能起到隔离变化的作用

分层体现了一种抽象和封装的设计思想。

- Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。
- 基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当替换数据库时，只需要改动 Repository 层的代码，Service 层的代码完全不需要修改。

Controller、Service、Repository 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。

- Repository 层基于数据库表，而数据库表改动的可能性很小，所以 Repository 层的代码最稳定，
- Controller 层提供适配给外部使用的接口，代码经常会变动。分层之后，Controller 层中代码的频繁改动并不会影响到稳定的 Repository 层。

### 分层能起到隔离关注点的作用

- Repository 层只关注数据的读写。
- Service 层只关注业务逻辑，不关注数据的来源。
- Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。

三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。

### 分层能提高代码的可测试性

> 单元测试不依赖不可控的外部组件，比如数据库。

分层之后，Repository 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，用 mock 的数据源替代真实的数据库，注入到 Service 层代码中。

### 分层能应对系统的复杂性

所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。当一个类或一个函数的代码过多之后，可读性、可维护性就会变差，就要想办法拆分。

拆分有垂直和水平两个方向。

- 水平方向基于业务来做拆分，就是模块化；
- 垂直方向基于流程来做拆分，就是这里说的分层。

不管是分层、模块化，还是 OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”。

## BO、VO、Entity存在的意义

针对 Controller、Service、Repository 三层，每层都会定义相应的数据对象，它们分别是 VO（View Object）、BO（Business Object）、Entity，例如 UserVo、UserBo、UserEntity。

在实际的开发中，VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，经常需要重复定义三个几乎一样的类，显然是一种重复劳动。

### 相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？

更加推荐每层都定义各自的数据对象这种设计思路，主要有以下3个方面的原因。

1. VO、BO、Entity 并非完全一样。比如，在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。
2. VO、BO、Entity 三个类**虽然代码重复，但功能语义不重复，从职责上讲是不一样的**。所以，也并不能算违背 DRY 原则。针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。
3. 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。**对于非常大的项目来说，结构清晰是第一位的！**

### 既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？

从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。

但是，如果有代码洁癖，对于代码重复的问题，也有一些办法来解决。

1. 继承可以解决代码重复问题。

    > 将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段。因为这里的继承层次很浅，也不复杂，所以使用继承并不会影响代码的可读性和可维护性。后期如果因为业务的需要，有些字段需要从父类移动到子类，或者从子类提取到父类，代码改起来也并不复杂。

2. “多用组合，少用继承”设计思想，组合也可以解决代码重复的问题。

    > 将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码。

### 不同分层之间的数据对象该如何互相转化呢？

当下一层的数据通过接口调用传递到上一层之后，需要将它转化成上一层对应的数据对象类型。

比如，Service 层从 Repository 层获取的 Entity 之后，将其转化成 BO，再继续业务逻辑的处理。所以，整个开发的过程会涉及“Entity 到 BO”和“BO 到 VO”这两种转化。

最简单的转化方式是**手动复制**。自己写代码在两个对象之间，**一个字段一个字段的赋值**。但这样的做法显然是没有技术含量的低级劳动。

> Java 中提供了多种数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。
>
> 如果用其他编程语言来做开发，也可以借鉴 Java 这些工具类的设计思路，在项目中实现对象转化工具类。

VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），还需要定义每个字段的 set 方法。

这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？

Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的 Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。

不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，**设计的问题本身就没有最优解，只有权衡**。为了使用方便，只能做一些妥协，放弃 BO 的封装特性，由开发者负责这些数据对象的不被错误使用。
