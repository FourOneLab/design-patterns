# 面向对象

封装、抽象、继承、多态，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。

## 封装（Encapsulation）

封装主要是**隐藏信息**、**保护数据**，类通过暴露有限地访问接口，授权外部仅能通过类提供的方法（或者叫函数）来访问内部信息或者数据。

### 封装的意义及能解决的编程问题

如果对类中属性的访问不做限制，任何代码都可以访问、修改类中的属性，这样虽然**灵活**，但是过度灵活就意味着不可控，属性可以被随意修改，修改逻辑散落在代码中的各个角落，影响代码的**可读性**和**可维护性**。

类仅仅通过有限的方法暴露必要的操作，也能提高类的**易用性**。如果把类属性都暴露给类的调用者，那么想要正确操作这些属性，就需要对业务细节有足够的了解，对于类的使用者来说也是一种**负担**。将属性封装起来，暴露几个必要的方法，调用者不用了解太多背后的细节，用错的概率小很多。

## 抽象（Abstraction）

抽象主要是**隐藏方法的具体实现**，让调用者只需要关系提供了哪些功能，并不需要指导这些功能是如何实现的。

在面向对象编程中，借助编程语言提供的接口类（interface）来实现抽象这个特性。抽象这个特性也可以不通过接口来实现，类的方法是通过编程语言中的函数这个语法机制实现的。通过函数包裹具体的实现逻辑，本身就是一种抽象。在 Golang 中对应的就是结构体和它的方法。 调用者在使用函数的时候，并不需要研究内部具体的实现逻辑，通过函数的命名、注释和文档，了解功能后就可以直接使用。

抽象这个特性有时候会被排除在面向对象的四大特性之外，因为抽象是一个非常通用的设计思想，不单单用在面向对象编程，也可以用来指导架构设计。这个特性不需要编程语言提供特殊的语法机制来支持，只需要提供函数这个基础的语法机制，就可以实现抽象特性。

### 抽象的意义及解决的编程问题

抽象和封装都是处理复杂性的有效手段，抽象作为一种只关注功能点不关注实现的设计思路，可以过滤非必要的信息。

很多设计原则都体现了抽象都设计思想，如基于接口而非基于实现编程，开闭原则（对扩展开放、对修改关闭）代码解耦（降低代码耦合度）等。

在命名类的方法时，也要有抽象思维，不要在方法定义中暴露太多实现细节，以保证在某个时间点需要改变方法的实现逻辑时，不用去修改其定义。

## 继承（Inheritance）

继承是用来表示类之间的is-a关系（如，小猫咪是一种哺乳动物）。

- 单继承：一个子类只继承一个父类
- 多继承：一个子类继承多个父类

继承需要编程语言提供特殊的语法支持：

- Java：`extends` 关键字【单继承】
- Ruby: 小于号(`<`)【单继承】
- C++：冒号(`:`)【多继承】
- Python：`parentheses()`【多继承】

### 继承的意义及解决的编程问题

继承通常都是真实世界在代码中的映射，比较符合人的认知。继承最大的好处就是代码复用。但是在 Golang 中没有继承，而是通过组合的方式实现代码的复用。

过度使用继承，继承层次过深过复杂，会导致代码可读性、可维护性差。因为子类继承自父类，相互之间就耦合在一起，父类的修改会直接影响子类。一般都是**多用组合少用继承**，这也是 Golang 的设计哲学。

### [组合优于继承](./composition-inheritance.go)

#### 为什么不推荐使用继承

> 有人觉得继承是一种反模式，应该尽量少用，甚至不用。

继承表示类之间的 is-a 关系，可以解决代码复用的问题，**虽然继承有诸多作用，但继承层次过深，过复杂，会影响代码但可维护性**。

如，例子中的鸟类和鸵鸟，继承 Fly 方法，又要重写 Fly 方法，一方面，增加编码的工作量，另一方面，违背了最小知识原则（Least Knowledge Principle，也叫最少知识原则或迪米特法则），**暴露不该暴露的接口给外币，增加了类使用过程中被误用的概览**。

像一些本身支持继承特性的编程语言，如Java，可以再继承两个抽象类，AbstractFlyableBird 和 AbstractUnFlyableBird，基于此实现的类，继承关系已经是三层了。如果我们再关注一下鸟会不会叫，再会不会飞的继承上又派生出四种抽象类，AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird。

依此类推，**关注的鸟类特征越多，类的继承层次会越来越深、继承关系会越来越复杂**。

层次很深、很复杂的继承关系：

- 一方面，代码可读性贼差，要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码，要一直追溯到最顶层父类的代码
- 另一方面，破坏了类的封装特性，父类的实现细节暴露给类子类，子类的实现又依赖父类的实现，两者高度耦合，一旦父类代码修改，会影响所有子类的逻辑

一句话，继承最大的问题在于：**继承层次过深，继承关系过于复杂，会影响到代码的可读性和可维护性**。

#### 组合比继承的优势

组合（composition）、接口、委托（delegation）三种技术手段，来解决继承存在的问题。

**接口表示具有某种行为特性**，还是上面鸟类的例子，针对飞这个特性，定义 Flyable 接口，针对叫这个特性，定义 Tweetable 接口，依此类推，定义 EggLayable 接口等。

继承的主要作用是，及可替代方案：

1. 表示 is-a 关系，可以被组合和接口替代
2. 支持多态特性，可以被接口替代
3. 代码复用，可以被组合和委托

因此，能不用继承就不用继承吧。

#### 如何判断该用组合还是继承

> 继承改写成组合意味着要做更细粒度的类的拆分，因此要定义更多的类和接口，这在一定程度上增加了代码的复杂程度和维护成本。

- 一般情况下，类之间的继承关系稳定，继承层次浅（最多两层），继承关系不复杂，就直接用继承，反之直接用组合。
- 一些业务之间并不具有继承关系，仅仅是为了代码复用，生硬的抽象出父类，会影响代码的可读性，这是使用组合更加合理、更加灵活。

一些设计模式会固定使用继承或组合：

- 组合关系：
  - 装饰者模式（decorator pattern）
  - 策略模式（strategy pattern）
  - 组合模式（composite pattern）
- 继承关系：
  - 模板模式（template pattern）
  
组合和继承各有优劣，各有适合的场景，当然 Golang 只有组合。

## 多态（Polymorphism）

多态是指子类可以替换父类，在实际的代码运行中，调用子类的方法实现。

多态的实现方式：

- 继承加上重写
- 实现接口
- duck-typing（动态语言支持，Python、JS等）

### duck-typing实现多态

```python
class Logger:
    def record(self):
        print("I write a log into file.")
        
class DB:
    def record(self):
        print("I insert data into db. ")
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

duck-typing 实现多态的方式非常灵活，Logger 和DB 类之间没有任何关系，不是继承、也不是接口和实现，只是他们都定义类 record 方法，传递给 test 方法，在实际执行时，调用对用的方法。

> 只要两个类具有相同的方法，就可以实现多态，不要求类之间有任何的关系，这就是 duck-typing，是动态语言特有的语法机制。

### 多态的意义及解决的编程问题

多态能提高代码的可扩展性和复用性。

- 可扩展性：增加新地实现类时，只要实现相应的接口即可，不需要改动以接口类为入参的函数
- 复用性：以接口类为入参的函数可以传入不同的实现类，相同逻辑只需要实现一次，不用针对每一个实现类编写相同的逻辑

多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖导致原则、里式替换原则、利用多态去掉冗余的 if-else 语句等。
