# 接口和抽象类

- 接口实现抽象、多态特性和基于接口而非实现的设计原则
- 抽象类实现继承和模板设计模式

> 区别：
> - 抽象类可以定义属性和方法的实现，接口不能定义属性，方法也不能包含代码。
> - 抽象类是一个不能被实例化，只能被继承（is-a 关系）的特殊类，接口是一种（has-a 关系）表示具有某个功能的协议。

## [抽象类](abstract.go)

> Golang 中没有抽象类这个语法特殊性，Demo 可能实现的不太好，看看就好。

1. 抽象类不允许被实例化，只能被继承
2. 抽象类可以包含属性和方法
3. 子类继承抽象类，必须实现抽象类中所有抽象方法

抽象类只能被继承，继承是为了解决代码复用的问题，所以抽象类就是**为代码复用而生**的。多个子类可以继承抽象类中的属性和方法，避免重复代码。

那么，直接通过父子类继承也可以达到代码复用的目的，因此抽象类的另一个好处就是实现多态，（因为在有抽象类这个语法的编程语言（如，Java）中会强制要求重写抽象类中所有的方法，而在父子类中不会有这个强制要求，强行实现多态，代码可读性差）。

## [接口](interface.go)

1. 接口不包含属性
2. 接口只能声明方法，方法不能包含实现代码
3. 类实现接口的时候，必须实现接口中声明的所有方法

抽象类更多是为了代码复用，而接口则侧重于解耦，相当于一组协议或契约，声明提供的功能，与具体地实现逻辑解耦，降低代码耦合性，提高代码扩展性。

**接口比抽象类应用的更加广泛，也更重要**。如基于接口而非实现编程的原则，极大提高代码的灵活性和扩展性。

使用接口还是抽象类的判断依据：

- 要表示一种 is-a 关系，并且是解决代码复用问题 ---> 抽象类
- 要表示一种 has-a 关系，并且是解决抽象而非代码复用的问题 ---> 接口

从类层次来看：

- 抽象类：是一种自下而上的设计思路，先有子类，再抽象为父类或抽象类
- 接口：是一种自上而下的设计思路，先设计接口，再考虑具体的实现

## [基于接口或抽象而非实现编程](interface_based.go)

可以指导细节的编程开发，也可以指导宏观的架构/系统设计。如C/S架构之间的接口设计，类库的接口设计。

> Program to an interface, not an implementation.
> 
> 接口，从本质上是一组**协议**或者**约定**，是功能提供者提供给使用者的一个**功能列表**。
> - 服务端与客户端之间的接口
> - 类库提供的接口
> - 一组通信协议，也可以叫接口
> - 编程语言中的接口或者抽象类

这条原则能够提高代码质量，它将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，当实现发生变化时，上游系统的代码基本上不用做变动，**降低耦合性**，**提高扩展性**。

**软件开发最大的挑战就是不断变化的需求，越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来需求的变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。**

抽象是提高代码可扩展性、灵活性、可维护性最有效的手段之一。

### 注意点

不要通过实现类来反推接口的定义，因为先把实现类写好，然后看实现类中有哪些方法，再照抄在接口定义中，这样可能会导致**接口定义不够抽象**，依赖具体的实现，这样的接口设计就没有意义了。

因此，按照这样反推的思路定义接口的时候，一定要选择性的定义接口，而不是把方法都放在接口中。

抽象意识、封装意识、接口意识很重要，定义接口的时候不要暴露实现细节，**接口的定义只是表明做什么，而不是怎么做**。设计接口的时候多思考下，这样的接口设计是否通用，是否能够做到替换具体的接口实现的时候，不需要任何接口定义的改动。

### 这个原则的意义以及解决的问题

并不需要为了满足这个原则，给每个实现类都定义对应的接口，任何事情都讲究一个度，过度使用导致接口太多，增加开发负担。

架构设计的本质就是权衡，回归到这个原则诞生的初衷，搞清楚为了解决什么问题而生，一切豁然开朗。

设计的初衷是：**将接口和实现相分离，封装不稳定的实现，暴露文稳定的接口**。

> 上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化时，上游系统的代码基本上不用改动，以此来**降低代码间的耦合性，提高代码的扩展性**。

因此，在业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，就没有必要为其设计接口，直接使用实现类即可。

**越是不稳定的系统，越需要在代码的扩展性、维护性方面下功夫**。如果某个系统很稳定，开发完成后基本不需要维护，那也没必要为扩展性而投入不必要的开发时间。