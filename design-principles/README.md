# SOLID

## SRP

单一职责原则（Single Responsibility Principle，SRP）：A class or module should have a single responsibility【一个类或者模块只负责完成一个职责/功能】。

> 模块和类的理解：
>
> - 模块比类更加抽象，类也可以看作是一种模块
>
> - 模块是比类粒度更粗的代码块，模块中包含多个类

### 如何判断类的职责是否够单一

不要设计大而全的类，要设计粒度小、功能单一的类。如果，一个类包含了两个或者两个以上业务不相干的功能，那它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

[示例](srp-example-1.go)

不同应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定是不一样的。

在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。

从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。如示例中的 UserInfo 类，从用户的角度看，符合单一职责原则，但是从用户展示信息、地址信息或登录认证信息角度看，就需要继续拆分。

**通常，先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。**

一些具有指导性的判断依据：

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，考虑对类进行拆分；
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，考虑对类进行拆分；
- 私有方法过多，考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
- 类中大量的方法都是集中操作类中的某几个属性，如示例 UserInfo 中一半的方法都是在操作 address 信息，考虑将这几个属性和对应的方法拆分出来。

### 类的职责是否设计的越单一越好

为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。

[示例](srp-example-2.go)

如果想让类的职责更加单一，那对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。

虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但代码的可维护性就降低了。

- 如果修改协议的格式，数据标识从 “`UEUEUE`” 改为 “`DFDFDF`”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。
- 而且，如果仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。

> 实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的**可读性**、**可扩展性**、**复用性**、**可维护性**等。在考虑应用某一个设计原则是否合理的时候，可以以此作为最终的考量标准。

## OCP

开闭原则（Open Closed Principle，OCP）是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则，因为，扩展性是代码质量最重要的衡量标准之一。

> 在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。

software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。也就是说，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

[示例](ocp-example-1.go)是 API 接口监控告警服务。

- 已经完成的功能：当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。
- 需要添加的新需求：当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。

[解决方案 1](ocp-example-2.go)，**基于修改的方式来添加新功能**，主要的修改有两处：

1. 修改 `Check()` 函数的入参，添加一个新的统计数据 timeoutCount
2. 在 `Check()` 函数中添加新 1.的告警逻辑

这个解决方案，修改了 `Check()` 函数，存在如下问题：

1. 调用这个函数的代码都要做相应的修改。
2. 这个函数相应的单元测试需要修改。

[解决方案 2](ocp-example-3.go)，**基于开闭原则（对扩展开放，对修改关闭）来添加新功能**，需要重构 Alert 类的代码，让它的扩展性更好，主要重构如下两部分：

1. 将 `Check()` 函数的多个入参封装成 ApiStatInfo 类
2. 引入 handler 概念，将 if 判断逻辑分散在各个 handler 中

基于重构之后的代码，添加每秒钟接口超时请求个数超过某个最大阈值就告警的新功能，主要有如下四处修改：
基于重构之后的代码，添加每秒钟接口超时请求个数超过某个最大阈值就告警的新功能，主要有如下四处修改：

1. 在 ApiStatInfo 类中添加新的属性 timeoutCount
2. 添加新的 TimeoutAlertHandler 类
3. 在 ApplicationContext 类的 `NewApplicationContext()` 方法中，往 alert 对象中注册新的 timeoutAlertHandler
4. 在使用 Alert 类的时候，需要给 `Check()` 函数的入参 apiStatInfo 对象设置 timeoutCount 的值

重构之后的代码更加**灵活**和**易扩展**。

添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 `Check()` 函数的逻辑。而且，只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。

### 修改代码是否意味着违背开闭原则

> 设计原则回顾，OCP: 软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。**只要没有破坏原有的代码的正常运行，没有破坏原有的单元测试**，就可以说，这是一个合格的代码改动。

在上面的解决方案 2 中，总共四处修改，只有 2 是基于扩展而非修改的方式，其他 3 个也是直接修改代码的。

从定义中可以看出，开闭原则可以应用在不同粒度的代码中：模块/类/方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。

比如，改动 1：

- 添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；
- 但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，又可以被认定为“扩展”。

比如，改动 3、4：不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。

> 因为，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。要做的是尽量让修改操作更集中、更少、更上层，尽量让**最核心、最复杂的那部分逻辑代码满足开闭原则**。

### 如何做到“对扩展开放、对修改关闭”

解决方案 2 通过引入一组 handler 的方式来实现支持开闭原则，这样的设计思路如何想到？**靠的就是理论知识和实战经验**。

实际上，开闭原则讲的就是代码的**扩展性**问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，如何做到“对扩展开放、对修改关闭”，也就粗略地等同于，如何才能写出扩展性好的代码。

**为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。**

> 在写代码的时候后，要多花时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。
>
> 识别出代码可变部分和不可变部分之后，**将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用**。当具体的实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。

实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。

通过这个[示例](ocp-example-4.go)，来展示多态、基于接口而非实现编程和抽象意识。

**开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。**

- 在某些场景下，代码的扩展性很重要，可以适当地牺牲一些代码的可读性；
- 另一些场景下，代码的可读性更加重要，可以适当地牺牲一些代码的可扩展性。

## LSP

里式替换原则（Liskov Substitution Principle, LSP）。

> 1986 年 Barbara Liskov：If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。
>
> 1996 年 Robert Martin：Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
>
> 21 世纪 中文版：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

在[示例](lsp-example-1.go)中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。

乍一看，通过接口实现了多态，里式替换和多态很类似的样子，那么，把示例稍微改造下就有感觉了。虽然改造之后的代码仍然可以通过多态语法，动态地用 SecurityTransporter 来替换 Transporter。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的。

虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但**关注角度不同**。

- 多态：是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种**代码实现的思路**。
- 里式替换：是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

### 明显违背 LSP 的代码

里式替换原则有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。

子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的**内部实现逻辑**，但不能改变函数**原有的行为约定**。这里的行为约定包括：

- 函数声明要实现的功能；例如，父类返回数据从小到大排序，子类按照时间先后排序，**违背里式替换原则**。
- 对输入、输出、异常的约定；例如，父类输入数据是任意整数，运行出错返回nil，数据为空返回空集合，子类输入数据只能是正整数，运行出错直接退出，数据为空返回nil，**违背里式替换原则**。
- 甚至包括注释中所罗列的任何特殊说明。例如，父类提现时没有透支功能，子类提现时对VIP提供透支功能，**违背里式替换原则**。

LSP原则中定义的父类和子类之间的关系，在 Golang 中就是接口和实现类之间的关系。

> 判断子类的设计实现是否违背里式替换原则的一个小窍门，拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就**有可能**说明，子类的设计实现没有完全地遵守父类的约定，子类**有可能**违背了里式替换原则。

## ISP

接口隔离原则（Interface Segregation Principle, ISP）。

> Clients should not be forced to depend upon interfaces that they do not use。直译成中文：客户端（接口的调用者或者使用者）不应该被强迫依赖它不需要的接口。

把“接口”理解为下面三种东西：

- 一组 API 接口集合
- 单个 API 接口或函数
- OOP 中的接口概念

### 一组 API 接口集合

如[示例](isp-example-1.go)，微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等。现在，后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。

解决方案：

1. 直接在UserService中添加删除用户的接口（deleteUserByCellphone、deleteUserById）会有安全隐患，所有使用用户系统的业务方都将有权限删除用户，出现误删的可能，而我们的需求只是让后台管理系统有删除用户的权限。
2. 从架构设计层面，通过接口鉴权的方式来限制接口的调用
3. 在没有鉴权框架支持的情况下，从代码设计的层面，尽量避免接口被误用

**参照接口隔离原则，调用者不应该强迫依赖它不需要的接口**，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只提供给后台管理系统来使用。这样的代码设计也符合Go语言中小接口的设计理念。

上面的示例中，把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。

在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

### 单个 API 接口或函数

把接口理解为单个接口或函数（不是函数计算中的函数，是代码层面的函数）。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。

在[示例](isp-example-2.go)中，`count()` 函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。按照接口隔离原则，应该把 `count()` 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。

从SRP原则的角度来看，`count()` 函数也存在职责是否单一的问题：

- 如果对每个统计需求，Statistics 定义的那几个统计信息都有涉及，那 `count()` 函数的设计就是合理的。
- 如果对每个统计需求，只涉及 Statistics 罗列的统计信息中一部分，比如，只需要 max、min、average 或者，只需要 average、sum。而 `count()` 函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。在这个应用场景下，`count()` 函数的设计就有点不合理，将其拆分成粒度更细的多个统计函数。

> 接口隔离原则跟单一职责原则有点类似，但稍有点区别。
>
> - 单一职责原则针对的是模块、类、接口的设计。
> - 而接口隔离原则，一方面更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

### OOP 中的接口

也就是编程语言中的 interface。

假设项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig。

如[示例](isp-example-3.go)。

#### 新需求1v

希望支持 Redis 和 Kafka 配置信息的热更新。但是，不希望对 MySQL 的配置信息进行热更新。

> 热更新（hot update）：如果在配置中心更改了配置信息，在不重启系统的情况下，能将最新的配置信息加载到内存中（也就是 RedisConfig、KafkaConfig 类中）。

解决方案：

- 设计实现一个 ScheduledUpdater 类，以固定时间频率（periodInSeconds）来调用 RedisConfig、KafkaConfig 的 `update()` 方法更新配置信息。

#### 新需求2

增加新的监控功能，通过命令行来查看 Zookeeper 中的配置信息是比较麻烦的。所以，希望能有一种更加方便的配置信息查看方式。只暴露 MySQL 和 Redis 的配置信息，不暴露 Kafka 的配置信息。

解决方案：

- 开发一个内嵌的 HTTP Server，输出项目的配置信息到一个固定地址，比如：<http://127.0.0.1:2389/config> 。只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。

#### 小结

在解决上述2个需求的国策和国内中国呢，设计了两个功能单一的接口：Updater 和 Viewer。

- ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。
- SimpleHttpServer 只依赖 Viewer 这个跟查看信息相关的接口，不需要被强迫依赖不需要的 Updater 接口，满足接口隔离原则。

如果不遵守接口隔离原则，不设计 Updater 和 Viewer 两个小接口，而是设计一个大而全的 Config 接口，让 RedisConfig、KafkaConfig、MysqlConfig 都实现这个 Config 接口，并且将原来传递给 ScheduledUpdater 的 Updater 和传递给 SimpleHttpServer 的 Viewer，都替换为 Config。

这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多，主要有两点原因。

- 首先，第一种设计思路更加灵活、易扩展、易复用。因为 Updater、Viewer 职责更加单一，单一就意味了通用、复用性好。
- 其次，第二种设计思路在代码实现上做了一些无用功。因为 Config 接口中包含两类不相关的接口，一类是 update()，一类是 output() 和 outputInPlainText()。要求 RedisConfig、KafkaConfig、MySqlConfig 必须同时实现 Config 的所有接口函数（update、output、outputInPlainText）。除此之外，如果要往 Config 中继续添加一个新的接口，那所有的实现类都要改动。相反，如果接口粒度比较小，那涉及改动的类就比较少。

## DIP

依赖反转原则。

### IOC

控制反转（Inversion Of Control，IOC）。

从[示例](dip-ioc.go)的两个测试案例可以看出，测试框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。开发时利用框架，只需要往预留的扩展点上，添加跟业务相关的代码，就可以利用框架来驱动整个程序流程的执行。这是一个典型的通过框架来实现“控制反转”的例子。

- 控制：指的是对程序执行流程的控制
- 反转：指的是没有使用框架前，需要自己控制整个程序的执行，使用框架后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。

> 实现控制反转的方法有很多，除了例子中类似于模板设计模式的方法之外，还有依赖注入等方法。

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，**一般用来指导框架层面的设计**。

### DI

依赖注入（Dependency Injection，DI）跟控制反转恰恰相反，它是一种具体的编码技巧。

> 依赖注入，用一句话来概括就是：不通过 `new()` 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

如[示例](dip-di.go)所示，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。

通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的**扩展性**，可以灵活地替换依赖的类，这一点在“开闭原则”中也有。

示例代码还有继续优化的空间，可以把 MessageSender 定义成接口，基于接口而非实现编程。

**依赖注入是编写可测试性代码最有效的手段。**

### DI Framework

上面的[示例测试文件](dip-di_test.go)中，采用依赖注入实现的 Notification 类中，虽然不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要自己来实现。

在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。

- 如果这部分工作都是自己写代码来完成，容易出错且开发成本也比较高。
- 而对象创建和依赖注入的工作，本身跟具体的业务无关，完全可以抽象成框架来自动完成。

这个框架就是“依赖注入框架”。只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

现成的依赖注入框架有很多，比如：

- Java 技术栈中：Google Guice、Java Spring、Pico Container、Butterfly Container 等，
- Golang 技术栈中：[Facebook inject](https://github.com/facebookarchive/inject)、[Uber dig](https://github.com/uber-go/dig)、[Google wire](https://github.com/google/wire) 等。

> Java Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。实际上，控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。

### 依赖倒置原则

依赖反转原则（Dependency Inversion Principle，DIP），也叫依赖倒置原则。

> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.
>
> 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

高层模块和低层模块的划分：

- 在调用链上，调用者属于高层，被调用者属于低层。
- 在业务开发中，高层模块依赖底层模块是没有任何问题的。

实际上，这条原则主要还是用来指导**框架层面的设计**，与控制反转类似。

以 Tomcat 这个 Servlet 容器作为例子来解释一下。

- Tomcat 是运行 Java Web 应用程序的容器。
- 编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。

按照之前的划分原则，Tomcat 就是高层模块，编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

## KISS

尽量保持简单（Keep It Simple and Stupid, KISS）。

> KISS 原则是一个万金油类型的设计原则，可以应用在很多场景中。不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、iPhone 手机的设计等等。

代码的**可读性**和**可维护性**是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。

- 代码足够简单，意味着很容易读懂，bug 比较难隐藏。
- 代码足够简单，意味着即便出现 bug，修复起来也比较简单。

**KISS看着简单，但是却不能落地，那不是很尴尬**。

### 代码行数与 KISS 的关系

如[示例](kiss-example-1.go)所示，实现一个检查输入的字符串 ipAddress 是否是合法的 IP 地址的功能，对比这三段代码，你觉得哪一段代码最符合 KISS 原则呢？

> 一个合法的 IP 地址由四个数字组成，并且通过“.”来进行分割。每组数字的取值范围是 0~255。第一组数字比较特殊，不允许为 0。

1. 第一段代码使用正则表达式，看似代码行数不多，但是最复杂（正则本身复杂，精通的人也少），正则表达式导致代码的可读性和可维护性都变差了，所以不符合KISS原则。
2. 第二段代码使用 net 库提供的 ParseIP 函数来实现，符合KISS原则。
3. 第三段代码是手写实现IP地址判断逻辑，示例代码只实现了部分功能，这样从头造轮子也比较容易写出BUG，不符合KISS原则。

> 一般来说，手写实现的逻辑会比类库的性能更高一些。
>
> 因为，工具类的功能都比较通用和全面，所以，在代码实现上，需要考虑和处理更多的细节，执行效率就会有所影响。
> 而自己实现逻辑时，完全是针对特定场景来处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。

不过，尽管第三种实现方式性能更高些，但更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种**过度优化**。除非 `IsValidIpAddress()` 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。

### 代码逻辑复杂与 KISS 的关系

并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 KISS 原则呢？

有请[示例]，这是一个KMP字符串匹配算法，这段代码逻辑复杂、实现难度大、可读性差的特点，但它并不违反 KISS 原则。

> 当需要处理长文本字符串匹配问题、字符串匹配是某个产品当核心功能或字符串匹配算法是系统当性能瓶颈时，优先选择高效的KMP算法。不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。

**本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。**

### 写出满足 KISS 原则的代码

1. 不要使用同事可能不懂的技术（正则表达式）或者一些编程语言中过于高级的语法来实现代码。
2. 不要重复造轮子，要善于使用已经有的工具类库，不要过度优化。
3. 不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

> 做开发的时候，一定不要过度设计，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。

## YAGNI

你不会需要它原则（You Ain’t Gonna Need It, YAGNI）。在软件开发中的时候，不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：**不要做过度设计**。

比如，系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，没必要提前编写这部分代码。只需要考虑代码的扩展性，预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。

再比如，不要在项目中提前引入不需要依赖的开发包。对于 Java 程序员来说，经常使用 Maven 或者 Gradle 来管理依赖的类库（library）。有些同事为了避免开发中 library 包缺失而频繁地修改 Maven 或者 Gradle 配置文件，提前往项目里引入大量常用的 library 包。实际上，这样的做法也是违背 YAGNI 原则的。

> 这个问题在 Golang 中有效的避免了，因为不实用的包是不能被引入的，编译时会报错，`_` 引入方式不算。

## DRY

不要重复自己原则（Don’t Repeat Yourself, DRY）。将它应用在编程中，可以理解为：不要写重复的代码。

从反例来学习DRY原则。主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。

### 实现重复逻辑

在[示例](dry-example-1.go)中，有两处非常明显的重复的代码片段：`isValidUserName()` 函数和 `isValidPassword()` 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将两个函数，合并为一个更通用的函数 `isValidUserNameOrPassword()`。

经过重构之后，代码行数减少了，也没有重复的代码了，但是，这和预期的不一样。合并之后的 `isValidUserNameOrPassword()` 函数，负责两件事情：验证用户名和验证密码，违反了“**单一职责原则**”和“**接口隔离原则**”。

`isValidUserName()` 和 `isValidPassword()` 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从**语义上并不重复**。

> 语义不重复：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。

尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。如果修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那 `isValidUserName()` 和 `isValidPassword()` 的实现逻辑就会不相同。

**尽管代码的实现逻辑是相同的，但语义不同，判定它并不违反 DRY 原则。对于包含重复代码的问题，通过抽象成更细粒度函数的方式来解决。**比如将校验只包含 a~z、0~9、dot 的逻辑封装成 `onlyContains()` 函数。

### 功能语义重复

在[示例](dry-example-2.go)中，有两个函数：`isValidIp()` 和 `checkIfIpValid()`。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的。

> 之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，其中一个同事在不知道已经有了 `isValidIp()` 的情况下，又定义并实现了同样用来校验 IP 地址是否合法的 `checkIfIpValid()` 函数。

- 上一个示例中，代码实现逻辑重复，但语义不重复，不认为它违反了 DRY 原则。
- 在这个示例中，代码的实现逻辑不重复，但语义重复（功能重复），认为它违反了 DRY 原则。

如果在项目中，不统一实现思路，在判断 IP 地址是否合法的时，有些地方调用了 `isValidIp()` 函数，有些地方又调用了 `checkIfIpValid()` 函数，导致代码很奇怪，相当于给代码“埋坑”，增加了阅读的难度。如果项目中 IP 地址是否合法的判定规则改变了，比如：255.255.255.255 不再被判定为合法的了，相应地，对 `isValidIp()` 的实现逻辑做了修改，但却忘记了修改 `checkIfIpValid()` 函数。这样会导致有些代码仍然使用老的 IP 地址判断逻辑，导致出现一些莫名其妙的 bug。

### 代码执行重复

在[示例](dry-example-3.go)中，UserService 的 `Login()` 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。

示例的代码中，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则，因为代码中存在“执行重复”。

1. 在 `Login()` 函数中，email 的校验逻辑被执行了两次。一次是在调用 `CheckIfUserExisted()` 函数的时候，另一次是调用 `GetUserByEmail()` 函数的时候。这个问题解决起来比较简单，只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。
2. 另一处比较隐蔽的执行重复，`Login()` 函数并不需要调用 `CheckIfUserExisted()` 函数，只需要调用一次 `GetUserByEmail()` 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。**这样的优化是很有必要的**。因为 `CheckIfUserExisted()` 函数和 `CheckIfUserExisted()` 函数都需要查询数据库，而数据库这类的 I/O 操作是比较耗时的，应当尽量减少这类 I/O 操作。

### CR

代码复用性（Code Reusability），代码的复用性是评判代码质量的一个非常重要的标准。

- 代码复用表示一种行为：在开发新功能的时候，尽量复用已经存在的代码。
- 代码的可复用性表示一段代码可被复用的特性或能力：在编写代码的时候，让代码尽量可复用。
- DRY 原则是一条原则：不要写重复的代码。

从定义描述上，好像有点类似，但深究起来，三者的区别还是蛮大的。

首先，**“不重复”并不代表“可复用”**。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。

其次，**“复用”和“可复用性”关注角度不同**。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。

> 尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了**减少代码量，提高代码的可读性、可维护性**。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。

“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。

#### 提高代码复用性

1. 减少代码耦合：对于高度耦合的代码，当希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，要尽量减少代码耦合。
2. 满足单一职责原则：如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合，就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。
3. 模块化：不单单指一组类构成的模块，还可以理解为单个类、函数。要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。
4. 业务与非业务逻辑分离：越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。为了复用跟业务无关的代码，将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。
5. 通用代码下沉：从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。**一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码**。所以，通用的代码尽量下沉到更下层。
6. 继承、多态、抽象、封装：
   1. 利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。
   2. 利用多态，可以动态地替换一段代码的部分逻辑，让这段代码可复用。
   3. 抽象，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。
   4. 代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。
7. 应用模板等设计模式：一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。

还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。

**复用意识非常重要**，在写代码的时候，要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性。

> 在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

## LOD

迪米特法则（Law of Demeter, LOD），能够帮实现代码的“高内聚、松耦合”。
> “高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，**缩小功能改动导致的代码改动范围**。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。

“高内聚、松耦合”是一个比较通用的设计思想：

- 可以用来指导不同粒度代码的设计与开发：比如系统、模块、类，甚至是函数
- 可以应用到不同的开发场景中，比如微服务、框架、组件、类库

以“类”作为这个设计思想的应用对象来，在这个设计思想中：

- “高内聚”用来指导**类本身**的设计：相近的功能放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。（单一职责原则是实现代码高内聚非常有效的设计原则）
- “松耦合”用来指导**类与类之间**依赖关系的设计：在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。（依赖注入、接口隔离、基于接口而非实现编程，迪米特法则，都是为了实现代码的松耦合。）

高内聚有助于松耦合，松耦合又需要高内聚的支持。

迪米特法则另一个名字叫最小知识原则（The Least Knowledge Principle）。

> Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.
>
> 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。

说人话：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。

迪米特法则包含前后两部分，这两部分讲的是两件事情，用两个实战案例分别来解读一下。

### 实战一

**不该有直接依赖关系的类之间，不要有依赖。**

通过[示例](lod-example-1.go)实现简化版的搜索引擎爬取网页的功能来说明。代码中包含三个主要的类：

- NetworkTransporter 类负责底层网络通信，根据请求获取数据；
- HtmlDownloader 类用来通过 URL 获取网页；
- Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。

示例中存在的问题：

1. NetworkTransporter 类：作为一个底层网络通信类，功能应尽可能通用，而不只是服务于下载 HTML，所以，不应该直接依赖太具体的发送对象 `http.Request`。这个设计违背迪米特法则，依赖了不该有直接依赖关系的类。
2. HtmlDownloader 类：设计的没有问题，需要根据 NetworkTransporter 类的变动而改动代码。
3. Document 类：存在如下三个问题：
   1. NewDocument()函数：逻辑比较复杂，耗时长，会影响代码的可测试性
   2. 通过NewXXX的方式来新建对象，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性
   3. 从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则

### 实战二

**有依赖关系的类之间，尽量只依赖必要的接口。**

如[示例](lod-example-2.go)所示，Serialization 类负责对象的序列化和反序列化。

单看这个类的设计，没有一点问题。放到一定的应用场景里，还有继续优化的空间。

#### 优化1

假设项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。

根据这个思路，将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类。

#### 优化2

拆分之后的代码满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。

对于优化后的示例如果修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，只需要修改一个类即可。在拆分之后，需要修改两个类。显然，这种设计思路的代码改动范围变大了。

如果既不想违背高内聚的设计思想，也不想违背迪米特法则，通过引入两个接口就能轻松解决这个问题。将接口作为传入的参数，那么只需要序列化的类就无感知反序列化操作了，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。

实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，总结出一条新的设计原则，那就是“**基于最小接口而非最大实现编程**”。

> 设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，在应用设计原则的时候，一定要具体问题具体分析。

对于示例中 Serialization 类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果对 Serialization 类添加更多的功能，实现更多更好用的序列化、反序列化函数，就需要重新考虑一下这个问题。
