# SOLID

## SRP

单一职责原则（Single Responsibility Principle，SRP）：A class or module should have a single responsibility【一个类或者模块只负责完成一个职责/功能】。

> 模块和类的理解：
>
> - 模块比类更加抽象，类也可以看作是一种模块
>
> - 模块是比类粒度更粗的代码块，模块中包含多个类

### 如何判断类的职责是否够单一

不要设计大而全的类，要设计粒度小、功能单一的类。如果，一个类包含了两个或者两个以上业务不相干的功能，那它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

[示例](./srp-example-1.go)

不同应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定是不一样的。

在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。

从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。如示例中的 UserInfo 类，从用户的角度看，符合单一职责原则，但是从用户展示信息、地址信息或登录认证信息角度看，就需要继续拆分。

**通常，先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。**

一些具有指导性的判断依据：

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，考虑对类进行拆分；
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，考虑对类进行拆分；
- 私有方法过多，考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
- 类中大量的方法都是集中操作类中的某几个属性，如示例 UserInfo 中一半的方法都是在操作 address 信息，考虑将这几个属性和对应的方法拆分出来。

### 类的职责是否设计的越单一越好

为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。

[示例](./srp-example-2.go)

如果想让类的职责更加单一，那对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。

虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但代码的可维护性就降低了。

- 如果修改协议的格式，数据标识从 “`UEUEUE`” 改为 “`DFDFDF`”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。
- 而且，如果仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。

> 实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的**可读性**、**可扩展性**、**复用性**、**可维护性**等。在考虑应用某一个设计原则是否合理的时候，可以以此作为最终的考量标准。

## OCP

开闭原则（Open Closed Principle，OCP）是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则，因为，扩展性是代码质量最重要的衡量标准之一。

> 在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。

software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。也就是说，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

[示例](./ocp-example-1.go)是 API 接口监控告警服务。

- 已经完成的功能：当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。
- 需要添加的新需求：当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。

[解决方案 1](./ocp-example-2.go)，**基于修改的方式来添加新功能**，主要的修改有两处：

1. 修改 `Check()` 函数的入参，添加一个新的统计数据 timeoutCount
2. 在 `Check()` 函数中添加新 1.的告警逻辑

这个解决方案，修改了 `Check()` 函数，存在如下问题：

1. 调用这个函数的代码都要做相应的修改。
2. 这个函数相应的单元测试需要修改。

[解决方案 2](./ocp-example-3.go)，**基于开闭原则（对扩展开放，对修改关闭）来添加新功能**，需要重构 Alert 类的代码，让它的扩展性更好，主要重构如下两部分：

1. 将 `Check()` 函数的多个入参封装成 ApiStatInfo 类
2. 引入 handler 概念，将 if 判断逻辑分散在各个 handler 中

基于重构之后的代码，添加每秒钟接口超时请求个数超过某个最大阈值就告警的新功能，主要有如下四处修改：
基于重构之后的代码，添加每秒钟接口超时请求个数超过某个最大阈值就告警的新功能，主要有如下四处修改：

1. 在 ApiStatInfo 类中添加新的属性 timeoutCount
2. 添加新的 TimeoutAlertHandler 类
3. 在 ApplicationContext 类的 `NewApplicationContext()` 方法中，往 alert 对象中注册新的 timeoutAlertHandler
4. 在使用 Alert 类的时候，需要给 `Check()` 函数的入参 apiStatInfo 对象设置 timeoutCount 的值

重构之后的代码更加**灵活**和**易扩展**。

添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 `Check()` 函数的逻辑。而且，只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。

### 修改代码是否意味着违背开闭原则

> 设计原则回顾，OCP: 软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。**只要没有破坏原有的代码的正常运行，没有破坏原有的单元测试**，就可以说，这是一个合格的代码改动。

在上面的解决方案 2 中，总共四处修改，只有 2 是基于扩展而非修改的方式，其他 3 个也是直接修改代码的。

从定义中可以看出，开闭原则可以应用在不同粒度的代码中：模块/类/方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。

比如，改动 1：

- 添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；
- 但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，又可以被认定为“扩展”。

比如，改动 3、4：不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。

> 因为，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。要做的是尽量让修改操作更集中、更少、更上层，尽量让**最核心、最复杂的那部分逻辑代码满足开闭原则**。

### 如何做到“对扩展开放、对修改关闭”

解决方案 2 通过引入一组 handler 的方式来实现支持开闭原则，这样的设计思路如何想到？**靠的就是理论知识和实战经验**。

实际上，开闭原则讲的就是代码的**扩展性**问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，如何做到“对扩展开放、对修改关闭”，也就粗略地等同于，如何才能写出扩展性好的代码。

**为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。**

> 在写代码的时候后，要多花时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。
>
> 识别出代码可变部分和不可变部分之后，**将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用**。当具体的实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。

实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。

通过这个[示例](./ocp-example-4.go)，来展示多态、基于接口而非实现编程和抽象意识。

**开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。**

- 在某些场景下，代码的扩展性很重要，可以适当地牺牲一些代码的可读性；
- 另一些场景下，代码的可读性更加重要，可以适当地牺牲一些代码的可扩展性。

## LSP

里式替换原则（Liskov Substitution Principle, LSP）。

> 1986 年 Barbara Liskov：If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。
>
> 1996 年 Robert Martin：Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
>
> 21 世纪 中文版：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

在[示例](./lsp-example-1.go)中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。

乍一看，通过接口实现了多态，里式替换和多态很类似的样子，那么，把示例稍微改造下就有感觉了。虽然改造之后的代码仍然可以通过多态语法，动态地用 SecurityTransporter 来替换 Transporter。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的。

虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但**关注角度不同**。

- 多态：是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种**代码实现的思路**。
- 里式替换：是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

### 明显违背 LSP 的代码

里式替换原则有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。

子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的**内部实现逻辑**，但不能改变函数**原有的行为约定**。这里的行为约定包括：

- 函数声明要实现的功能；例如，父类返回数据从小到大排序，子类按照时间先后排序，**违背里式替换原则**。
- 对输入、输出、异常的约定；例如，父类输入数据是任意整数，运行出错返回nil，数据为空返回空集合，子类输入数据只能是正整数，运行出错直接退出，数据为空返回nil，**违背里式替换原则**。
- 甚至包括注释中所罗列的任何特殊说明。例如，父类提现时没有透支功能，子类提现时对VIP提供透支功能，**违背里式替换原则**。

LSP原则中定义的父类和子类之间的关系，在 Golang 中就是接口和实现类之间的关系。

> 判断子类的设计实现是否违背里式替换原则的一个小窍门，拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就**有可能**说明，子类的设计实现没有完全地遵守父类的约定，子类**有可能**违背了里式替换原则。

