# SOLID

## SRP

单一职责原则（Single Responsibility Principle，SRP）：A class or module should have a single responsibility【一个类或者模块只负责完成一个职责/功能】。

> 模块和类的理解：
>
> - 模块比类更加抽象，类也可以看作是一种模块
>
> - 模块是比类粒度更粗的代码块，模块中包含多个类

### 如何判断类的职责是否够单一

不要设计大而全的类，要设计粒度小、功能单一的类。如果，一个类包含了两个或者两个以上业务不相干的功能，那它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

[示例](./srp-example-1.go)

不同应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定是不一样的。

在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。

从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。如示例中的 UserInfo 类，从用户的角度看，符合单一职责原则，但是从用户展示信息、地址信息或登录认证信息角度看，就需要继续拆分。

**通常，先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。**

一些具有指导性的判断依据：

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，考虑对类进行拆分；
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，考虑对类进行拆分；
- 私有方法过多，考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
- 类中大量的方法都是集中操作类中的某几个属性，如示例 UserInfo 中一半的方法都是在操作 address 信息，考虑将这几个属性和对应的方法拆分出来。

### 类的职责是否设计的越单一越好

为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。

[示例](./srp-example-2.go)

如果想让类的职责更加单一，那对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。

虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但代码的可维护性就降低了。

- 如果修改协议的格式，数据标识从 “`UEUEUE`” 改为 “`DFDFDF`”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。
- 而且，如果仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。

> 实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的**可读性**、**可扩展性**、**复用性**、**可维护性**等。在考虑应用某一个设计原则是否合理的时候，可以以此作为最终的考量标准。

## OCP

开闭原则（Open Closed Principle，OCP）是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则，因为，扩展性是代码质量最重要的衡量标准之一。

> 在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。

software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。也就是说，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

[示例](./ocp-example-1.go)是 API 接口监控告警服务。

- 已经完成的功能：当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。
- 需要添加的新需求：当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。

[解决方案 1](./ocp-example-2.go)，**基于修改的方式来添加新功能**，主要的修改有两处：

1. 修改 `Check()` 函数的入参，添加一个新的统计数据 timeoutCount
2. 在 `Check()` 函数中添加新 1.的告警逻辑

这个解决方案，修改了 `Check()` 函数，存在如下问题：

1. 调用这个函数的代码都要做相应的修改。
2. 这个函数相应的单元测试需要修改。

[解决方案 2](./ocp-example-3.go)，**基于开闭原则（对扩展开放，对修改关闭）来添加新功能**，需要重构 Alert 类的代码，让它的扩展性更好，主要重构如下两部分：

1. 将 `Check()` 函数的多个入参封装成 ApiStatInfo 类
2. 引入 handler 概念，将 if 判断逻辑分散在各个 handler 中

基于重构之后的代码，添加每秒钟接口超时请求个数超过某个最大阈值就告警的新功能，主要有如下四处修改：
基于重构之后的代码，添加每秒钟接口超时请求个数超过某个最大阈值就告警的新功能，主要有如下四处修改：

1. 在 ApiStatInfo 类中添加新的属性 timeoutCount
2. 添加新的 TimeoutAlertHandler 类
3. 在 ApplicationContext 类的 `NewApplicationContext()` 方法中，往 alert 对象中注册新的 timeoutAlertHandler
4. 在使用 Alert 类的时候，需要给 `Check()` 函数的入参 apiStatInfo 对象设置 timeoutCount 的值

重构之后的代码更加**灵活**和**易扩展**。

添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 `Check()` 函数的逻辑。而且，只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。

### 修改代码是否意味着违背开闭原则

> 设计原则回顾，OCP: 软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。**只要没有破坏原有的代码的正常运行，没有破坏原有的单元测试**，就可以说，这是一个合格的代码改动。

在上面的解决方案 2 中，总共四处修改，只有 2 是基于扩展而非修改的方式，其他 3 个也是直接修改代码的。

从定义中可以看出，开闭原则可以应用在不同粒度的代码中：模块/类/方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。

比如，改动 1：

- 添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；
- 但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，又可以被认定为“扩展”。

比如，改动 3、4：不管从哪个层面（模块、类、方法）来讲，都不能算是“扩展”，而是地地道道的“修改”。不过，有些修改是在所难免的，是可以被接受的。

> 因为，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。要做的是尽量让修改操作更集中、更少、更上层，尽量让**最核心、最复杂的那部分逻辑代码满足开闭原则**。

### 如何做到“对扩展开放、对修改关闭”

解决方案 2 通过引入一组 handler 的方式来实现支持开闭原则，这样的设计思路如何想到？**靠的就是理论知识和实战经验**。

实际上，开闭原则讲的就是代码的**扩展性**问题，是判断一段代码是否易扩展的“金标准”。如果某段代码在应对未来需求变化的时候，能够做到“对扩展开放、对修改关闭”，那就说明这段代码的扩展性比较好。所以，如何做到“对扩展开放、对修改关闭”，也就粗略地等同于，如何才能写出扩展性好的代码。

**为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。**

> 在写代码的时候后，要多花时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。
>
> 识别出代码可变部分和不可变部分之后，**将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用**。当具体的实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。

实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“很多设计原则、思想、模式都是相通的”这一思想。

通过这个[示例](./ocp-example-4.go)，来展示多态、基于接口而非实现编程和抽象意识。

**开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。**

- 在某些场景下，代码的扩展性很重要，可以适当地牺牲一些代码的可读性；
- 另一些场景下，代码的可读性更加重要，可以适当地牺牲一些代码的可扩展性。

## LSP

里式替换原则（Liskov Substitution Principle, LSP）。

> 1986 年 Barbara Liskov：If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。
>
> 1996 年 Robert Martin：Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。
>
> 21 世纪 中文版：子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

在[示例](./lsp-example-1.go)中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。

乍一看，通过接口实现了多态，里式替换和多态很类似的样子，那么，把示例稍微改造下就有感觉了。虽然改造之后的代码仍然可以通过多态语法，动态地用 SecurityTransporter 来替换 Transporter。但是，从设计思路上来讲，SecurityTransporter 的设计是不符合里式替换原则的。

虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但**关注角度不同**。

- 多态：是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种**代码实现的思路**。
- 里式替换：是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

### 明显违背 LSP 的代码

里式替换原则有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。

子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的**内部实现逻辑**，但不能改变函数**原有的行为约定**。这里的行为约定包括：

- 函数声明要实现的功能；例如，父类返回数据从小到大排序，子类按照时间先后排序，**违背里式替换原则**。
- 对输入、输出、异常的约定；例如，父类输入数据是任意整数，运行出错返回nil，数据为空返回空集合，子类输入数据只能是正整数，运行出错直接退出，数据为空返回nil，**违背里式替换原则**。
- 甚至包括注释中所罗列的任何特殊说明。例如，父类提现时没有透支功能，子类提现时对VIP提供透支功能，**违背里式替换原则**。

LSP原则中定义的父类和子类之间的关系，在 Golang 中就是接口和实现类之间的关系。

> 判断子类的设计实现是否违背里式替换原则的一个小窍门，拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就**有可能**说明，子类的设计实现没有完全地遵守父类的约定，子类**有可能**违背了里式替换原则。

## ISP

接口隔离原则（Interface Segregation Principle, ISP）。

> Clients should not be forced to depend upon interfaces that they do not use。直译成中文：客户端（接口的调用者或者使用者）不应该被强迫依赖它不需要的接口。

把“接口”理解为下面三种东西：

- 一组 API 接口集合
- 单个 API 接口或函数
- OOP 中的接口概念

### 一组 API 接口集合

如[示例](isp-example-1.go)，微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等。现在，后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。

解决方案：

1. 直接在UserService中添加删除用户的接口（deleteUserByCellphone、deleteUserById）会有安全隐患，所有使用用户系统的业务方都将有权限删除用户，出现误删的可能，而我们的需求只是让后台管理系统有删除用户的权限。
2. 从架构设计层面，通过接口鉴权的方式来限制接口的调用
3. 在没有鉴权框架支持的情况下，从代码设计的层面，尽量避免接口被误用

**参照接口隔离原则，调用者不应该强迫依赖它不需要的接口**，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只提供给后台管理系统来使用。这样的代码设计也符合Go语言中小接口的设计理念。

上面的示例中，把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。

在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

### 单个 API 接口或函数

把接口理解为单个接口或函数（不是函数计算中的函数，是代码层面的函数）。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。

在[示例](isp-example-2.go)中，`count()` 函数的功能不够单一，包含很多不同的统计功能，比如，求最大值、最小值、平均值等等。按照接口隔离原则，应该把 `count()` 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。

从SRP原则的角度来看，`count()` 函数也存在职责是否单一的问题：

- 如果对每个统计需求，Statistics 定义的那几个统计信息都有涉及，那 `count()` 函数的设计就是合理的。
- 如果对每个统计需求，只涉及 Statistics 罗列的统计信息中一部分，比如，只需要 max、min、average 或者，只需要 average、sum。而 `count()` 函数每次都会把所有的统计信息计算一遍，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。在这个应用场景下，`count()` 函数的设计就有点不合理，将其拆分成粒度更细的多个统计函数。

> 接口隔离原则跟单一职责原则有点类似，但稍有点区别。
>
> - 单一职责原则针对的是模块、类、接口的设计。
> - 而接口隔离原则，一方面更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

### OOP 中的接口

也就是编程语言中的 interface。

假设项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig。

如[示例](isp-example-3.go)。

#### 新需求1v

希望支持 Redis 和 Kafka 配置信息的热更新。但是，不希望对 MySQL 的配置信息进行热更新。

> 热更新（hot update）：如果在配置中心更改了配置信息，在不重启系统的情况下，能将最新的配置信息加载到内存中（也就是 RedisConfig、KafkaConfig 类中）。

解决方案：

- 设计实现一个 ScheduledUpdater 类，以固定时间频率（periodInSeconds）来调用 RedisConfig、KafkaConfig 的 `update()` 方法更新配置信息。

#### 新需求2

增加新的监控功能，通过命令行来查看 Zookeeper 中的配置信息是比较麻烦的。所以，希望能有一种更加方便的配置信息查看方式。只暴露 MySQL 和 Redis 的配置信息，不暴露 Kafka 的配置信息。

解决方案：

- 开发一个内嵌的 HTTP Server，输出项目的配置信息到一个固定地址，比如：<http://127.0.0.1:2389/config> 。只需要在浏览器中输入这个地址，就可以显示出系统的配置信息。

#### 小结

在解决上述2个需求的国策和国内中国呢，设计了两个功能单一的接口：Updater 和 Viewer。

- ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。
- SimpleHttpServer 只依赖 Viewer 这个跟查看信息相关的接口，不需要被强迫依赖不需要的 Updater 接口，满足接口隔离原则。

如果不遵守接口隔离原则，不设计 Updater 和 Viewer 两个小接口，而是设计一个大而全的 Config 接口，让 RedisConfig、KafkaConfig、MysqlConfig 都实现这个 Config 接口，并且将原来传递给 ScheduledUpdater 的 Updater 和传递给 SimpleHttpServer 的 Viewer，都替换为 Config。

这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多，主要有两点原因。

- 首先，第一种设计思路更加灵活、易扩展、易复用。因为 Updater、Viewer 职责更加单一，单一就意味了通用、复用性好。
- 其次，第二种设计思路在代码实现上做了一些无用功。因为 Config 接口中包含两类不相关的接口，一类是 update()，一类是 output() 和 outputInPlainText()。要求 RedisConfig、KafkaConfig、MySqlConfig 必须同时实现 Config 的所有接口函数（update、output、outputInPlainText）。除此之外，如果要往 Config 中继续添加一个新的接口，那所有的实现类都要改动。相反，如果接口粒度比较小，那涉及改动的类就比较少。

## DIP

依赖反转原则。

### IOC

控制反转（Inversion Of Control，IOC）。

从[示例](./dip-ioc.go)的两个测试案例可以看出，测试框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。开发时利用框架，只需要往预留的扩展点上，添加跟业务相关的代码，就可以利用框架来驱动整个程序流程的执行。这是一个典型的通过框架来实现“控制反转”的例子。

- 控制：指的是对程序执行流程的控制
- 反转：指的是没有使用框架前，需要自己控制整个程序的执行，使用框架后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。

> 实现控制反转的方法有很多，除了例子中类似于模板设计模式的方法之外，还有依赖注入等方法。

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，**一般用来指导框架层面的设计**。

### DI

依赖注入（Dependency Injection，DI）跟控制反转恰恰相反，它是一种具体的编码技巧。

> 依赖注入，用一句话来概括就是：不通过 `new()` 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

如[示例](./dip-di.go)所示，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。

通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的**扩展性**，可以灵活地替换依赖的类，这一点在“开闭原则”中也有。

示例代码还有继续优化的空间，可以把 MessageSender 定义成接口，基于接口而非实现编程。

**依赖注入是编写可测试性代码最有效的手段。**

### DI Framework

上面的[示例测试文件](dip-di_test.go)中，采用依赖注入实现的 Notification 类中，虽然不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要自己来实现。

在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。

- 如果这部分工作都是自己写代码来完成，容易出错且开发成本也比较高。
- 而对象创建和依赖注入的工作，本身跟具体的业务无关，完全可以抽象成框架来自动完成。

这个框架就是“依赖注入框架”。只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

现成的依赖注入框架有很多，比如：

- Java 技术栈中：Google Guice、Java Spring、Pico Container、Butterfly Container 等，
- Golang 技术栈中：[Facebook inject](https://github.com/facebookarchive/inject)、[Uber dig](https://github.com/uber-go/dig)、[Google wire](https://github.com/google/wire) 等。

> Java Spring 框架自己声称是控制反转容器（Inversion Of Control Container）。实际上，控制反转容器这种表述是一种非常宽泛的描述，DI 依赖注入框架的表述更具体、更有针对性。实现控制反转的方式有很多，除了依赖注入，还有模板模式等，而 Spring 框架的控制反转主要是通过依赖注入来实现的。

### DIP

依赖反转原则（Dependency Inversion Principle，DIP），也叫依赖倒置原则。

> High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.
>
> 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

高层模块和低层模块的划分：

- 在调用链上，调用者属于高层，被调用者属于低层。
- 在业务开发中，高层模块依赖底层模块是没有任何问题的。

实际上，这条原则主要还是用来指导**框架层面的设计**，与控制反转类似。

以 Tomcat 这个 Servlet 容器作为例子来解释一下。

- Tomcat 是运行 Java Web 应用程序的容器。
- 编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。

按照之前的划分原则，Tomcat 就是高层模块，编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。
